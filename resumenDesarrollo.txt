================================================================================
RESUMEN DE DESARROLLO - SaaS Cuentas Corrientes
================================================================================
Fecha: 2025-11-20
Branch actual: 8-usuario-por-autogesti√≥n

================================================================================
√öLTIMA IMPLEMENTACI√ìN: Sistema de Registro con Dos Botones Separados
================================================================================

DESCRIPCI√ìN:
------------
Se implement√≥ un sistema completo de registro que permite crear cuentas de dos
tipos diferentes: Comercios y Clientes. La soluci√≥n utiliza DOS BOTONES
SEPARADOS en la interfaz de registro para proporcionar claridad inmediata al
usuario sobre qu√© tipo de cuenta desea crear.

DECISI√ìN DE DISE√ëO:
-------------------
‚úì DOS BOTONES SEPARADOS (Implementado)
  - Bot√≥n 1: "Registrar Comercio" - Para negocios
  - Bot√≥n 2: "Registrar Cliente" - Para clientes de comercios existentes

  Ventajas:
  ‚Ä¢ Claridad inmediata sobre qu√© se va a crear
  ‚Ä¢ Menos pasos en el flujo de registro
  ‚Ä¢ Mejor UX para perfiles claramente diferenciados
  ‚Ä¢ No hay ambig√ºedad ni decisiones adicionales

‚úó UN SOLO BOT√ìN + SELECT (Rechazado)
  - Requiere pasos adicionales
  - Mayor fricci√≥n en el proceso

================================================================================
ARCHIVOS CREADOS/MODIFICADOS
================================================================================

BACKEND - API (.NET 8)
----------------------

NUEVOS ARCHIVOS:
1. SaasACC.Model/Servicios/Login/RegisterComercioRequest.cs
   - DTO para registro de comercio
   - Validaciones: nombre, email, tel√©fono, direcci√≥n del comercio
   - Datos del administrador: nombre, email, password con confirmaci√≥n

2. SaasACC.Model/Servicios/Login/RegisterClienteRequest.cs
   - DTO para registro de cliente
   - Validaciones: nombre, apellido, email, tel√©fono
   - Campos opcionales: DNI, direcci√≥n
   - Referencia a ComercioId

3. SaasACC.Model/Servicios/Login/RegisterResponse.cs
   - Respuesta unificada para ambos tipos de registro
   - Incluye: Success, Message, Token, ComercioId, ClienteId, ErrorMessage

4. SaasACC.Application/Interfaces/IComercioRepository.cs
   - Interfaz del repositorio de comercios
   - M√©todos: GetByIdAsync, GetByEmailAsync, GetAllAsync, CreateAsync, etc.

5. SaasACC.Infrastructure/Repositories/ComercioRepository.cs
   - Implementaci√≥n del repositorio de comercios
   - CRUD completo con validaciones
   - Soft delete implementado

6. SaasACCAPI.api/Controllers/ComerciosController.cs
   - Endpoint GET /api/comercios - Lista comercios activos
   - Retorna ComercioDto simplificado

ARCHIVOS MODIFICADOS:
1. SaasACC.Application/Services/AuthService.cs
   - A√±adida interfaz IAuthService:
     ‚Ä¢ RegisterComercioAsync(RegisterComercioRequest)
     ‚Ä¢ RegisterClienteAsync(RegisterClienteRequest)

   - Implementaci√≥n RegisterComercioAsync:
     ‚Ä¢ Valida email del comercio √∫nico
     ‚Ä¢ Valida email del administrador √∫nico
     ‚Ä¢ Crea comercio
     ‚Ä¢ Crea usuario administrador con rol "Admin"
     ‚Ä¢ Genera token JWT autom√°ticamente

   - Implementaci√≥n RegisterClienteAsync:
     ‚Ä¢ Valida que el comercio existe
     ‚Ä¢ Valida email √∫nico dentro del comercio
     ‚Ä¢ Crea cliente
     ‚Ä¢ Crea cuenta corriente autom√°ticamente

   - A√±adido m√©todo HashPassword (SHA256)

2. SaasACC.Application/Interfaces/IUsuarioRepository.cs
   - A√±adido m√©todo: CreateAsync(Usuario)

3. SaasACC.Infrastructure/Repositories/UsuarioRepository.cs
   - Implementado m√©todo CreateAsync
   - Establece FechaCreacion y Activo autom√°ticamente

4. SaasACCAPI.api/Controllers/AuthController.cs
   - Endpoint POST /api/auth/register/comercio
     ‚Ä¢ Valida ModelState
     ‚Ä¢ Logging de intentos y resultados
     ‚Ä¢ Retorna RegisterResponse con token

   - Endpoint POST /api/auth/register/cliente
     ‚Ä¢ Valida ModelState
     ‚Ä¢ Logging de intentos y resultados
     ‚Ä¢ Retorna RegisterResponse

5. SaasACCAPI.api/Program.cs
   - Registrado IComercioRepository en DI container
   - L√≠nea a√±adida: builder.Services.AddScoped<IComercioRepository, ComercioRepository>();

FRONTEND - BLAZOR WASM
----------------------

NUEVOS ARCHIVOS:
1. SaasACC.BlazorWasm/Pages/Auth/Register.razor
   - P√°gina principal de registro
   - DOS BOTONES CLARAMENTE DIFERENCIADOS:
     ‚Ä¢ Bot√≥n Primary: "Registrar Comercio" con icono Business
       ‚îî‚îÄ Descripci√≥n: "Para negocios que desean gestionar cuentas corrientes"
     ‚Ä¢ Bot√≥n Outlined: "Registrar Cliente" con icono Person
       ‚îî‚îÄ Descripci√≥n: "Para clientes con cuenta en un comercio existente"
   - Link a login para usuarios existentes
   - Layout: EmptyLayout (sin men√∫s de navegaci√≥n)

2. SaasACC.BlazorWasm/Pages/Auth/RegisterComercio.razor
   - Formulario completo de registro de comercio
   - Secci√≥n 1 - Datos del Comercio:
     ‚Ä¢ Nombre del comercio (requerido)
     ‚Ä¢ Email del comercio (requerido, validaci√≥n email)
     ‚Ä¢ Tel√©fono (requerido)
     ‚Ä¢ Direcci√≥n (requerido, multilinea)

   - Secci√≥n 2 - Datos del Administrador:
     ‚Ä¢ Nombre del administrador (requerido)
     ‚Ä¢ Email del administrador (requerido)
     ‚Ä¢ Password (requerido, con toggle visibilidad)
     ‚Ä¢ Confirmar password (requerido, validaci√≥n coincidencia)

   - Validaciones en tiempo real con MudBlazor
   - Bot√≥n de env√≠o con loading spinner
   - Bot√≥n "Volver" a selecci√≥n de tipo
   - Al registrar exitosamente: redirige a /admin/clientes

3. SaasACC.BlazorWasm/Pages/Auth/RegisterCliente.razor
   - Formulario de registro de cliente
   - Carga lista de comercios desde API en OnInitializedAsync
   - Dropdown para seleccionar comercio
   - Campos del cliente:
     ‚Ä¢ Nombre (requerido)
     ‚Ä¢ Apellido (requerido)
     ‚Ä¢ Email (requerido)
     ‚Ä¢ Tel√©fono (requerido)
     ‚Ä¢ DNI (opcional)
     ‚Ä¢ Direcci√≥n (opcional)

   - Loading spinner mientras carga comercios
   - Validaciones integradas
   - Al registrar: muestra mensaje de √©xito y redirige a /login

ARCHIVOS MODIFICADOS:
1. SaasACC.BlazorWasm/Services/IAuthService.cs
   - A√±adidos m√©todos a la interfaz:
     ‚Ä¢ RegisterComercio(RegisterComercioRequest)
     ‚Ä¢ RegisterCliente(RegisterClienteRequest)

2. SaasACC.BlazorWasm/Services/AuthService.cs
   - Implementado RegisterComercio:
     ‚Ä¢ POST a api/auth/register/comercio
     ‚Ä¢ Si exitoso: guarda token, role "Admin", comercioId en localStorage
     ‚Ä¢ Notifica a AuthStateProvider
     ‚Ä¢ Retorna RegisterResponse

   - Implementado RegisterCliente:
     ‚Ä¢ POST a api/auth/register/cliente
     ‚Ä¢ No guarda token (solo registro, no login autom√°tico)
     ‚Ä¢ Retorna RegisterResponse

3. SaasACC.BlazorWasm/Pages/Auth/Login.razor
   - A√±adido link de registro despu√©s del bot√≥n de login:
     ‚Ä¢ "¬øNo tienes cuenta?"
     ‚Ä¢ Link: "Crear cuenta" ‚Üí /register
   - Separador visual (MudDivider)

================================================================================
FLUJO DE USUARIO IMPLEMENTADO
================================================================================

1. INICIO EN LOGIN
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ   Login.razor       ‚îÇ
   ‚îÇ  Email / Password   ‚îÇ
   ‚îÇ  [Iniciar Sesi√≥n]   ‚îÇ
   ‚îÇ                     ‚îÇ
   ‚îÇ  ¬øNo tienes cuenta? ‚îÇ
   ‚îÇ  ‚Üí Crear cuenta     ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
                               ‚ñº
2. SELECCI√ìN DE TIPO DE CUENTA
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ       Register.razor                 ‚îÇ
   ‚îÇ                                      ‚îÇ
   ‚îÇ  [Registrar Comercio] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
   ‚îÇ   üìä Para negocios              ‚îÇ    ‚îÇ
   ‚îÇ                                 ‚îÇ    ‚îÇ
   ‚îÇ  [Registrar Cliente] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ    ‚îÇ
   ‚îÇ   üë§ Para clientes          ‚îÇ   ‚îÇ    ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ   ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ                                          ‚îÇ
         ‚ñº                                          ‚ñº
3A. REGISTRO COMERCIO              3B. REGISTRO CLIENTE
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇRegisterComercio     ‚îÇ           ‚îÇRegisterCliente      ‚îÇ
   ‚îÇ                     ‚îÇ           ‚îÇ                     ‚îÇ
   ‚îÇ Datos Comercio:     ‚îÇ           ‚îÇ Seleccionar:        ‚îÇ
   ‚îÇ ‚Ä¢ Nombre            ‚îÇ           ‚îÇ ‚Ä¢ Comercio (dropdown)‚îÇ
   ‚îÇ ‚Ä¢ Email             ‚îÇ           ‚îÇ                     ‚îÇ
   ‚îÇ ‚Ä¢ Tel√©fono          ‚îÇ           ‚îÇ Tus Datos:          ‚îÇ
   ‚îÇ ‚Ä¢ Direcci√≥n         ‚îÇ           ‚îÇ ‚Ä¢ Nombre            ‚îÇ
   ‚îÇ                     ‚îÇ           ‚îÇ ‚Ä¢ Apellido          ‚îÇ
   ‚îÇ Datos Admin:        ‚îÇ           ‚îÇ ‚Ä¢ Email             ‚îÇ
   ‚îÇ ‚Ä¢ Nombre            ‚îÇ           ‚îÇ ‚Ä¢ Tel√©fono          ‚îÇ
   ‚îÇ ‚Ä¢ Email             ‚îÇ           ‚îÇ ‚Ä¢ DNI (opcional)    ‚îÇ
   ‚îÇ ‚Ä¢ Password          ‚îÇ           ‚îÇ ‚Ä¢ Direcci√≥n (opc)   ‚îÇ
   ‚îÇ ‚Ä¢ Confirmar Pass    ‚îÇ           ‚îÇ                     ‚îÇ
   ‚îÇ                     ‚îÇ           ‚îÇ                     ‚îÇ
   ‚îÇ [Crear Cuenta]      ‚îÇ           ‚îÇ [Crear Cuenta]      ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ                                 ‚îÇ
          ‚îÇ                                 ‚îÇ
          ‚ñº                                 ‚ñº
   API: POST /auth/register/comercio   API: POST /auth/register/cliente
   ‚Ä¢ Crea Comercio                     ‚Ä¢ Valida Comercio existe
   ‚Ä¢ Crea Usuario Admin                ‚Ä¢ Crea Cliente
   ‚Ä¢ Hash password (SHA256)            ‚Ä¢ Crea CuentaCorriente
   ‚Ä¢ Genera JWT Token                  ‚Ä¢ Sin login autom√°tico
          ‚îÇ                                 ‚îÇ
          ‚ñº                                 ‚ñº
   Guarda token en localStorage        Mensaje de √©xito
   Redirige: /admin/clientes          Redirige: /login

================================================================================
ENDPOINTS API CREADOS
================================================================================

1. POST /api/auth/register/comercio
   Request Body: RegisterComercioRequest
   {
     "nombreComercio": "string",
     "emailComercio": "string",
     "telefonoComercio": "string",
     "direccionComercio": "string",
     "nombreAdmin": "string",
     "emailAdmin": "string",
     "password": "string",
     "confirmPassword": "string"
   }

   Response: RegisterResponse
   {
     "success": true,
     "message": "Comercio registrado exitosamente",
     "token": "eyJhbGc...",
     "comercioId": 1,
     "clienteId": null,
     "errorMessage": ""
   }

   C√≥digos HTTP:
   - 200 OK: Registro exitoso
   - 400 Bad Request: Datos inv√°lidos o email duplicado
   - 500 Internal Server Error: Error del servidor

2. POST /api/auth/register/cliente
   Request Body: RegisterClienteRequest
   {
     "nombre": "string",
     "apellido": "string",
     "email": "string",
     "telefono": "string",
     "dni": "string (opcional)",
     "direccion": "string (opcional)",
     "comercioId": 1,
     "password": "string (opcional, futuro)",
     "confirmPassword": "string (opcional, futuro)"
   }

   Response: RegisterResponse
   {
     "success": true,
     "message": "Cliente registrado exitosamente",
     "token": "",
     "comercioId": 1,
     "clienteId": 5,
     "errorMessage": ""
   }

   C√≥digos HTTP:
   - 200 OK: Registro exitoso
   - 400 Bad Request: Comercio no existe o email duplicado
   - 500 Internal Server Error: Error del servidor

3. GET /api/comercios
   Response: Array<ComercioDto>
   [
     {
       "id": 1,
       "nombre": "Mi Comercio",
       "email": "contacto@micomercio.com",
       "telefono": "+54 9 11 1234-5678"
     }
   ]

   C√≥digos HTTP:
   - 200 OK: Lista obtenida exitosamente
   - 500 Internal Server Error: Error del servidor

================================================================================
ESTRUCTURA DE BASE DE DATOS
================================================================================

TABLAS INVOLUCRADAS:

1. Comercios
   - Id (PK)
   - Nombre
   - Email (√∫nico)
   - Telefono
   - Direccion
   - Logo (nullable)
   - NotificacionesEmail
   - NotificacionesWhatsApp
   - FechaCreacion
   - FechaModificacion (nullable)
   - Activo (soft delete)

2. Usuarios
   - Id (PK)
   - Nombre
   - Email
   - PasswordHash (SHA256)
   - Rol ("Admin", "Usuario", "SuperAdmin")
   - ComercioId (FK ‚Üí Comercios)
   - UltimoAcceso (nullable)
   - FechaCreacion
   - FechaModificacion (nullable)
   - Activo (soft delete)

3. Clientes
   - Id (PK)
   - Nombre
   - Apellido
   - Email
   - Telefono
   - DNI (nullable)
   - Direccion (nullable)
   - ComercioId (FK ‚Üí Comercios)
   - FechaCreacion
   - FechaModificacion (nullable)
   - Activo (soft delete)

4. CuentasCorrientes (creada autom√°ticamente al registrar cliente)
   - Id (PK)
   - ClienteId (FK ‚Üí Clientes)
   - LimiteCredito
   - Bloqueada
   - Observaciones (nullable)
   - FechaCreacion
   - FechaModificacion (nullable)
   - Activo (soft delete)

RELACIONES:
- Comercio 1:N Usuarios
- Comercio 1:N Clientes
- Cliente 1:1 CuentaCorriente

================================================================================
TECNOLOG√çAS UTILIZADAS
================================================================================

BACKEND:
- .NET 8
- ASP.NET Core Web API
- Entity Framework Core
- SQL Server LocalDB
- JWT Bearer Authentication
- SHA256 para hashing de passwords

FRONTEND:
- Blazor WebAssembly
- MudBlazor (Material Design)
- Blazored.LocalStorage
- HttpClient para llamadas API
- Custom AuthenticationStateProvider

HERRAMIENTAS:
- Visual Studio 2022
- Git (Branch: 8-usuario-por-autogesti√≥n)

================================================================================
VALIDACIONES IMPLEMENTADAS
================================================================================

BACKEND (Data Annotations):
‚úì Campos requeridos (Required)
‚úì Validaci√≥n de email (EmailAddress)
‚úì Validaci√≥n de tel√©fono (Phone)
‚úì Longitud m√°xima de strings (StringLength)
‚úì Longitud m√≠nima de password (MinimumLength: 6)
‚úì Comparaci√≥n de passwords (Compare)

BACKEND (L√≥gica de negocio):
‚úì Email de comercio √∫nico en toda la BD
‚úì Email de usuario √∫nico en toda la BD
‚úì Email de cliente √∫nico por comercio
‚úì Comercio debe existir al registrar cliente
‚úì Creaci√≥n autom√°tica de CuentaCorriente al crear Cliente

FRONTEND (MudBlazor):
‚úì Validaci√≥n en tiempo real
‚úì Mensajes de error personalizados
‚úì Validaci√≥n de formato de email
‚úì Validaci√≥n de campos requeridos
‚úì Comparaci√≥n de passwords en cliente

================================================================================
SEGURIDAD
================================================================================

IMPLEMENTADO:
‚úì Passwords hasheados con SHA256
‚úì JWT Token con expiraci√≥n de 24 horas
‚úì Claims en JWT: UserId, Email, Name, Role, ComercioId
‚úì CORS configurado para Blazor WASM
‚úì Endpoints de registro sin autenticaci√≥n (p√∫blicos)
‚úì Validaci√≥n de ModelState en controllers
‚úì Soft delete en todas las entidades

RECOMENDACIONES FUTURAS:
‚ö† Cambiar de SHA256 a BCrypt o Argon2 (m√°s seguro)
‚ö† Implementar rate limiting en endpoints de registro
‚ö† A√±adir verificaci√≥n de email
‚ö† A√±adir CAPTCHA para prevenir bots
‚ö† Implementar refresh tokens
‚ö† Logs de auditor√≠a de registros

================================================================================
TESTING
================================================================================

ESTADO: Compilaci√≥n exitosa
- Todos los proyectos compilan sin errores
- Warnings menores no cr√≠ticos

TESTS PENDIENTES:
‚ñ° Unit tests de servicios
‚ñ° Integration tests de endpoints
‚ñ° Tests de validaciones
‚ñ° Tests de UI con bUnit

TESTING MANUAL RECOMENDADO:
1. Registrar comercio nuevo
   - Verificar creaci√≥n en BD
   - Verificar usuario admin creado
   - Verificar login autom√°tico con token
   - Verificar redirecci√≥n a /admin/clientes

2. Registrar cliente
   - Verificar que aparezcan comercios en dropdown
   - Verificar creaci√≥n de cliente
   - Verificar creaci√≥n autom√°tica de cuenta corriente
   - Verificar redirecci√≥n a login

3. Validaciones
   - Email duplicado de comercio
   - Email duplicado de usuario
   - Email duplicado de cliente en mismo comercio
   - Passwords no coinciden
   - Campos requeridos vac√≠os

================================================================================
PR√ìXIMOS PASOS SUGERIDOS
================================================================================

1. FUNCIONALIDAD:
   ‚ñ° Implementar "Olvid√© mi contrase√±a"
   ‚ñ° A√±adir verificaci√≥n de email
   ‚ñ° Permitir a clientes crear password para autogesti√≥n
   ‚ñ° Dashboard para clientes registrados
   ‚ñ° Notificaciones de registro por email

2. SEGURIDAD:
   ‚ñ° Migrar de SHA256 a BCrypt
   ‚ñ° Implementar rate limiting
   ‚ñ° A√±adir CAPTCHA
   ‚ñ° Implementar refresh tokens
   ‚ñ° Two-factor authentication (2FA)

3. UX/UI:
   ‚ñ° Wizard multi-paso para registro de comercio
   ‚ñ° Validaci√≥n as√≠ncrona de emails (verificar duplicados en tiempo real)
   ‚ñ° Preview de plan/precio antes de registrar comercio
   ‚ñ° Onboarding despu√©s del primer registro
   ‚ñ° Tour guiado para nuevos usuarios

4. T√âCNICO:
   ‚ñ° A√±adir tests unitarios
   ‚ñ° Implementar logging estructurado (Serilog)
   ‚ñ° Configurar Health Checks
   ‚ñ° Implementar versionado de API
   ‚ñ° Documentaci√≥n Swagger mejorada

================================================================================
NOTAS IMPORTANTES
================================================================================

‚Ä¢ El sistema permite registros sin verificaci√≥n de email (futuro)
‚Ä¢ Los clientes NO tienen login autom√°tico (solo comercios)
‚Ä¢ Las cuentas corrientes se crean autom√°ticamente con l√≠mite 0
‚Ä¢ Los passwords se hashean con SHA256 (recomendado cambiar a BCrypt)
‚Ä¢ Todos los campos tienen soft delete (Activo = false)
‚Ä¢ El token JWT incluye ComercioId para multi-tenancy
‚Ä¢ El sistema est√° preparado para multi-comercio desde el dise√±o

================================================================================
IMPLEMENTACI√ìN: Sistema de Aprobaci√≥n de Clientes con Autogesti√≥n
================================================================================
Fecha: 2025-11-20
Branch: 8-usuario-por-autogesti√≥n

DESCRIPCI√ìN:
------------
Se implement√≥ un sistema completo de aprobaci√≥n de clientes que diferencia entre
clientes creados por administradores (aprobados autom√°ticamente) y clientes que
se auto-registran (requieren aprobaci√≥n manual del comercio).

DECISI√ìN ARQUITECT√ìNICA CLAVE:
-------------------------------
‚úì TABLA USUARIO UNIFICADA (Implementado)
  - Usuarios con rol "Cliente" autentican en tabla Usuario
  - Cliente.UsuarioId es FK nullable a Usuario
  - Beneficios:
    ‚Ä¢ Sistema de autenticaci√≥n unificado
    ‚Ä¢ Mejor arquitectura a largo plazo
    ‚Ä¢ Facilita implementaci√≥n de roles
    ‚Ä¢ No duplica l√≥gica de passwords

‚úó PASSWORDHASH EN CLIENTE (Rechazado)
  - Habr√≠a duplicado l√≥gica de autenticaci√≥n
  - Dif√≠cil de mantener

================================================================================
ARCHIVOS CREADOS/MODIFICADOS
================================================================================

BACKEND - MODEL (ENTIDADES)
---------------------------

NUEVOS ARCHIVOS:
1. SaasACC.Model/Entities/EstadoCliente.cs
   - Nueva entidad para estados de cliente
   - Estados: Pendiente (1), Activo (2), Inactivo (3)
   - Sistema extensible para agregar m√°s estados en el futuro
   - Campos:
     ‚Ä¢ Id (int)
     ‚Ä¢ Nombre (string)
     ‚Ä¢ Descripcion (string?)
     ‚Ä¢ Clientes (ICollection<Cliente>)

ARCHIVOS MODIFICADOS:
1. SaasACC.Model/Entities/Cliente.cs
   - A√±adido EstadoId (int) - FK a EstadoCliente
   - A√±adido UsuarioId (int?) - FK nullable a Usuario
   - A√±adido OrigenRegistro (int):
     ‚Ä¢ 1: Administraci√≥n (creado por admin)
     ‚Ä¢ 2: Autogesti√≥n (auto-registrado)
   - A√±adido FechaAprobacion (DateTime?)
   - A√±adido AprobadoPorUsuarioId (int?) - FK a Usuario
   - Navegaci√≥n: Estado, Usuario, AprobadoPor

2. SaasACC.Model/Entities/Usuario.cs
   - A√±adido Apellido (string?)
   - Modificado Rol para soportar "Cliente"
   - A√±adido ClientesAprobados (ICollection<Cliente>)

BACKEND - INFRASTRUCTURE (BASE DE DATOS)
-----------------------------------------

ARCHIVOS MODIFICADOS:
1. SaasACC.Infrastructure/ApplicationDbContext.cs
   - A√±adido DbSet<EstadoCliente>
   - Configuraci√≥n de EstadoCliente:
     ‚Ä¢ HasData con 3 estados iniciales
   - Configuraci√≥n de Cliente:
     ‚Ä¢ Relaci√≥n con EstadoCliente (requerida)
     ‚Ä¢ Relaci√≥n con Usuario (nullable)
     ‚Ä¢ Relaci√≥n con AprobadoPor (nullable)
     ‚Ä¢ OnDelete: Restrict para evitar cascadas
   - Configuraci√≥n de Usuario:
     ‚Ä¢ Relaci√≥n ClientesAprobados (sin FK inversa)

2. SaasACC.Infrastructure/Migrations/20251121020405_AgregarSistemaAprobacionClientes.cs
   - Creaci√≥n de tabla EstadoCliente
   - Seed de 3 estados iniciales
   - A√±adidas columnas a Cliente:
     ‚Ä¢ EstadoId (int, requerido, default 2)
     ‚Ä¢ UsuarioId (int?, nullable)
     ‚Ä¢ OrigenRegistro (int, default 1)
     ‚Ä¢ FechaAprobacion (DateTime?)
     ‚Ä¢ AprobadoPorUsuarioId (int?)
   - A√±adida columna a Usuario:
     ‚Ä¢ Apellido (string?, max 100)
   - MIGRACI√ìN DE DATOS EXISTENTES:
     ‚Ä¢ UPDATE Clientes SET EstadoId = 2, OrigenRegistro = 2
     ‚Ä¢ Marca todos los clientes existentes como Activos y de Autogesti√≥n
   - √çndices en FK para mejor performance
   - Constraints de FK con OnDelete Restrict

BACKEND - REPOSITORIES
----------------------

ARCHIVOS MODIFICADOS:
1. SaasACC.Application/Interfaces/IClienteRepository.cs
   - Modificado GetAllAsync(comercioId, estadoId?) - A√±adido filtro opcional
   - A√±adido CrearCuentaCorrienteAsync(clienteId)

2. SaasACC.Infrastructure/Repositories/ClienteRepository.cs
   - Modificado GetAllAsync:
     ‚Ä¢ Include de Estado, Usuario
     ‚Ä¢ Filtro condicional por EstadoId
     ‚Ä¢ Query optimizada

   - Implementado CrearCuentaCorrienteAsync:
     ‚Ä¢ Verifica si ya existe cuenta corriente
     ‚Ä¢ Crea nueva si no existe
     ‚Ä¢ Inicializa con l√≠mite 0
     ‚Ä¢ Retorna cuenta creada o existente

   - Modificado CreateAsync:
     ‚Ä¢ YA NO crea cuenta corriente autom√°ticamente
     ‚Ä¢ La cuenta se crea solo en aprobaci√≥n

BACKEND - SERVICES
------------------

ARCHIVOS MODIFICADOS:
1. SaasACC.Application/Services/ClienteService.cs (IClienteService)
   - A√±adidos m√©todos a interfaz:
     ‚Ä¢ GetClientesPendientesAsync(comercioId)
     ‚Ä¢ AprobarClienteAsync(clienteId, aprobadoPorUsuarioId)
     ‚Ä¢ RechazarClienteAsync(clienteId, rechazadoPorUsuarioId)

   - Modificado CreateClienteAsync:
     ‚Ä¢ EstadoId = 2 (Activo) - auto-aprobado
     ‚Ä¢ OrigenRegistro = 1 (Administraci√≥n)
     ‚Ä¢ FechaAprobacion = DateTime.UtcNow
     ‚Ä¢ Crea cuenta corriente inmediatamente
     ‚Ä¢ Recarga cliente con cuenta antes de retornar

   - Implementado GetClientesPendientesAsync:
     ‚Ä¢ Llama a GetAllAsync con estadoId = 1
     ‚Ä¢ Retorna lista de ClienteDto

   - Implementado AprobarClienteAsync:
     ‚Ä¢ Valida que cliente existe
     ‚Ä¢ Valida que no est√© ya aprobado
     ‚Ä¢ Cambia EstadoId a 2 (Activo)
     ‚Ä¢ Establece FechaAprobacion
     ‚Ä¢ Registra AprobadoPorUsuarioId
     ‚Ä¢ Crea cuenta corriente
     ‚Ä¢ Recarga cliente con cuenta
     ‚Ä¢ Retorna ClienteDto

   - Implementado RechazarClienteAsync:
     ‚Ä¢ Valida que cliente existe
     ‚Ä¢ Cambia EstadoId a 3 (Inactivo)
     ‚Ä¢ Registra quien rechaz√≥ en AprobadoPorUsuarioId
     ‚Ä¢ NO crea cuenta corriente
     ‚Ä¢ Retorna ClienteDto

2. SaasACC.Application/Services/AuthService.cs
   - Modificado LoginAsync:
     ‚Ä¢ Si usuario.Rol == "Cliente":
       - Busca cliente asociado por email
       - Valida que cliente.EstadoId == 2 (Activo)
       - Si EstadoId == 1: "Pendiente de aprobaci√≥n"
       - Si EstadoId == 3: "Cuenta inactivada"
       - Incluye ClienteId en el token
     ‚Ä¢ Token JWT incluye claim "ClienteId" si aplica

   - Modificado RegisterClienteAsync:
     ‚Ä¢ Crea Usuario con rol "Cliente" PRIMERO
     ‚Ä¢ Hashea password
     ‚Ä¢ Crea Cliente vinculado a Usuario:
       - UsuarioId = usuario.Id
       - EstadoId = 1 (Pendiente)
       - OrigenRegistro = 2 (Autogesti√≥n)
     ‚Ä¢ NO crea cuenta corriente (se crea en aprobaci√≥n)
     ‚Ä¢ NO genera token (cliente debe esperar aprobaci√≥n)

BACKEND - DTOs
--------------

ARCHIVOS MODIFICADOS:
1. SaasACC.Model/DTOs/ClienteDto.cs
   - A√±adido EstadoId (int)
   - A√±adido EstadoNombre (string)
   - A√±adido OrigenRegistro (int)
   - A√±adido OrigenRegistroNombre (string) - Computed:
     ‚Ä¢ OrigenRegistro == 1 ‚Üí "Administraci√≥n"
     ‚Ä¢ OrigenRegistro == 2 ‚Üí "Autogesti√≥n"
   - A√±adido TieneUsuario (bool)
   - A√±adido FechaAprobacion (DateTime?)

BACKEND - API (CONTROLLERS)
---------------------------

ARCHIVOS MODIFICADOS:
1. SaasACCAPI.api/Controllers/ClientesController.cs
   - Modificado GetClientes:
     ‚Ä¢ A√±adido par√°metro [FromQuery] int? estadoId
     ‚Ä¢ Pasa estadoId al servicio para filtrado

   - A√±adido endpoint GetClientesPendientes:
     ‚Ä¢ [HttpGet("pendientes")]
     ‚Ä¢ Retorna solo clientes con EstadoId = 1
     ‚Ä¢ Requiere autenticaci√≥n

   - A√±adido endpoint AprobarCliente:
     ‚Ä¢ [HttpPost("{id}/aprobar")]
     ‚Ä¢ Obtiene usuarioId del token
     ‚Ä¢ Llama a AprobarClienteAsync
     ‚Ä¢ Maneja InvalidOperationException (ya aprobado)
     ‚Ä¢ Retorna ClienteDto actualizado

   - A√±adido endpoint RechazarCliente:
     ‚Ä¢ [HttpPost("{id}/rechazar")]
     ‚Ä¢ Obtiene usuarioId del token
     ‚Ä¢ Llama a RechazarClienteAsync
     ‚Ä¢ Retorna ClienteDto actualizado

   - A√±adido m√©todo privado GetUsuarioIdFromToken:
     ‚Ä¢ Extrae NameIdentifier del token
     ‚Ä¢ Retorna int usuarioId
     ‚Ä¢ Throw UnauthorizedAccessException si falla

FRONTEND - BLAZOR WASM (PAGES)
------------------------------

NUEVOS ARCHIVOS:
1. SaasACC.BlazorWasm/Pages/Admin/ClientesPendientes.razor
   - P√°gina dedicada a clientes pendientes de aprobaci√≥n
   - Ruta: /admin/clientes-pendientes
   - Autorizaci√≥n: [Authorize(Roles = "Admin,SuperAdmin")]
   - Componentes:
     ‚Ä¢ MudCard con t√≠tulo
     ‚Ä¢ MudProgressCircular durante carga
     ‚Ä¢ MudAlert si no hay pendientes
     ‚Ä¢ MudTable con columnas:
       - Nombre completo
       - Email
       - Tel√©fono
       - DNI
       - Origen (chip con color)
       - Fecha de registro
       - Acciones (Aprobar/Rechazar)

   - M√©todos:
     ‚Ä¢ LoadClientesPendientes: GET api/clientes/pendientes
     ‚Ä¢ AprobarCliente: POST api/clientes/{id}/aprobar
     ‚Ä¢ RechazarCliente: POST api/clientes/{id}/rechazar

   - UX:
     ‚Ä¢ Botones verde (Aprobar) y rojo (Rechazar)
     ‚Ä¢ Iconos CheckCircle y Cancel
     ‚Ä¢ Snackbar con mensajes de √©xito/error
     ‚Ä¢ Recarga autom√°tica despu√©s de aprobar/rechazar
     ‚Ä¢ Bot√≥n "Volver a Clientes"

ARCHIVOS MODIFICADOS:
1. SaasACC.BlazorWasm/Pages/Admin/Clientes.razor
   - A√±adido filtro de estado:
     ‚Ä¢ MudSelect con opciones: Todos, Pendientes, Activos, Inactivos
     ‚Ä¢ Variable selectedEstadoId
     ‚Ä¢ Se pasa como query parameter a API

   - A√±adidas columnas en tabla:
     ‚Ä¢ Estado (MudChip con colores):
       - Pendiente: Warning (amarillo)
       - Activo: Success (verde)
       - Inactivo: Default (gris)
     ‚Ä¢ Origen (MudChip):
       - Administraci√≥n: Primary
       - Autogesti√≥n: Info

   - Modificadas acciones:
     ‚Ä¢ Si EstadoId == 1 (Pendiente):
       - Mostrar botones Aprobar/Rechazar
       - Iconos CheckCircle/Cancel
       - Colores Success/Error
     ‚Ä¢ Si EstadoId != 1:
       - Mostrar botones Edit/Delete normales

   - A√±adidos m√©todos:
     ‚Ä¢ AprobarCliente(cliente): POST api/clientes/{id}/aprobar
     ‚Ä¢ RechazarCliente(cliente): POST api/clientes/{id}/rechazar

   - A√±adido bot√≥n de acceso r√°pido:
     ‚Ä¢ "Ver Pendientes" (solo si hay pendientes)
     ‚Ä¢ Navega a /admin/clientes-pendientes
     ‚Ä¢ Badge con cantidad de pendientes

2. SaasACC.BlazorWasm/App.razor
   - A√±adido <MudPopoverProvider /> despu√©s de MudSnackbarProvider
   - Fix para error "Missing <MudPopoverProvider />"

================================================================================
ENDPOINTS API CREADOS/MODIFICADOS
================================================================================

MODIFICADOS:
1. GET /api/clientes?estadoId={estadoId}
   Query Parameters:
   - estadoId (int?, opcional): 1=Pendiente, 2=Activo, 3=Inactivo

   Response: Array<ClienteDto>
   - Incluye nuevos campos: EstadoId, EstadoNombre, OrigenRegistro, etc.

NUEVOS:
2. GET /api/clientes/pendientes
   Descripci√≥n: Obtiene solo clientes pendientes de aprobaci√≥n
   Autorizaci√≥n: Requerida (token JWT)

   Response: Array<ClienteDto>
   [
     {
       "id": 5,
       "nombre": "Juan",
       "apellido": "P√©rez",
       "nombreCompleto": "Juan P√©rez",
       "email": "juan@example.com",
       "estadoId": 1,
       "estadoNombre": "Pendiente",
       "origenRegistro": 2,
       "origenRegistroNombre": "Autogesti√≥n",
       "tieneUsuario": true,
       "fechaAprobacion": null,
       "cuentaCorriente": null
     }
   ]

3. POST /api/clientes/{id}/aprobar
   Descripci√≥n: Aprueba un cliente pendiente
   Autorizaci√≥n: Requerida (obtiene usuarioId del token)

   Request: Sin body

   Response: ClienteDto
   {
     "id": 5,
     "estadoId": 2,
     "estadoNombre": "Activo",
     "fechaAprobacion": "2025-11-20T10:30:00Z",
     "cuentaCorriente": {
       "id": 8,
       "clienteId": 5,
       "saldo": 0,
       "fechaCreacion": "2025-11-20T10:30:00Z"
     }
   }

   Errores:
   - 400: Cliente ya est√° aprobado
   - 400: Cliente no encontrado
   - 500: Error interno

4. POST /api/clientes/{id}/rechazar
   Descripci√≥n: Rechaza un cliente pendiente
   Autorizaci√≥n: Requerida (obtiene usuarioId del token)

   Request: Sin body

   Response: ClienteDto
   {
     "id": 5,
     "estadoId": 3,
     "estadoNombre": "Inactivo"
   }

================================================================================
CAMBIOS EN BASE DE DATOS
================================================================================

NUEVA TABLA:
1. EstadoCliente
   - Id (int, PK)
   - Nombre (nvarchar(50))
   - Descripcion (nvarchar(200), nullable)

   DATOS INICIALES:
   | Id | Nombre    | Descripcion               |
   |----|-----------|---------------------------|
   | 1  | Pendiente | Pendiente de aprobaci√≥n   |
   | 2  | Activo    | Cliente activo            |
   | 3  | Inactivo  | Cliente inactivo          |

COLUMNAS A√ëADIDAS A CLIENTES:
- EstadoId (int, NOT NULL, DEFAULT 2, FK ‚Üí EstadoCliente)
- UsuarioId (int, NULL, FK ‚Üí Usuarios)
- OrigenRegistro (int, NOT NULL, DEFAULT 1)
- FechaAprobacion (datetime2, NULL)
- AprobadoPorUsuarioId (int, NULL, FK ‚Üí Usuarios)

COLUMNAS A√ëADIDAS A USUARIOS:
- Apellido (nvarchar(100), NULL)

√çNDICES CREADOS:
- IX_Clientes_EstadoId
- IX_Clientes_UsuarioId
- IX_Clientes_AprobadoPorUsuarioId

FOREIGN KEYS:
- FK_Clientes_EstadoCliente_EstadoId (ON DELETE RESTRICT)
- FK_Clientes_Usuarios_UsuarioId (ON DELETE RESTRICT)
- FK_Clientes_Usuarios_AprobadoPorUsuarioId (ON DELETE RESTRICT)

MIGRACI√ìN DE DATOS:
- Todos los clientes existentes:
  ‚Ä¢ EstadoId = 2 (Activo)
  ‚Ä¢ OrigenRegistro = 2 (Autogesti√≥n)

================================================================================
FLUJO DE USUARIO ACTUALIZADO
================================================================================

FLUJO 1: ADMINISTRADOR CREA CLIENTE
------------------------------------
1. Admin ingresa a /admin/clientes
2. Click en "Nuevo Cliente"
3. Completa formulario
4. Al guardar:
   Backend:
   - Crea Cliente con EstadoId = 2 (Activo)
   - OrigenRegistro = 1 (Administraci√≥n)
   - FechaAprobacion = ahora
   - Crea CuentaCorriente inmediatamente
   Frontend:
   - Muestra mensaje de √©xito
   - Cliente aparece en lista como "Activo"
   - Origen: "Administraci√≥n"

FLUJO 2: CLIENTE SE AUTO-REGISTRA
----------------------------------
1. Usuario visita /register
2. Click en "Registrar Cliente"
3. Selecciona comercio del dropdown
4. Completa formulario (nombre, email, password, etc.)
5. Al enviar:
   Backend:
   - Crea Usuario con rol "Cliente"
   - Crea Cliente con:
     ‚Ä¢ UsuarioId = usuario.Id
     ‚Ä¢ EstadoId = 1 (Pendiente)
     ‚Ä¢ OrigenRegistro = 2 (Autogesti√≥n)
   - NO crea CuentaCorriente a√∫n
   Frontend:
   - Mensaje: "Registro exitoso. Espera aprobaci√≥n del comercio"
   - Redirige a /login

FLUJO 3: CLIENTE INTENTA LOGIN (PENDIENTE)
-------------------------------------------
1. Cliente ingresa email/password
2. Backend:
   - Valida credenciales
   - Busca Cliente asociado
   - Verifica EstadoId
   - Como EstadoId == 1 (Pendiente):
     ‚Ä¢ Retorna error: "Tu cuenta est√° pendiente de aprobaci√≥n"
3. Frontend:
   - Muestra mensaje de error
   - No permite acceso

FLUJO 4: ADMIN APRUEBA CLIENTE
-------------------------------
1. Admin ve notificaci√≥n de clientes pendientes
2. Navega a /admin/clientes-pendientes
   O
   Filtra por "Pendientes" en /admin/clientes
3. Ve lista de clientes con estado "Pendiente"
4. Click en bot√≥n "Aprobar"
5. Backend:
   - Cambia EstadoId a 2 (Activo)
   - Registra FechaAprobacion
   - Registra AprobadoPorUsuarioId
   - Crea CuentaCorriente
6. Frontend:
   - Mensaje: "{Nombre} aprobado correctamente"
   - Cliente desaparece de lista de pendientes
   - Aparece en lista de activos

FLUJO 5: CLIENTE LOGIN DESPU√âS DE APROBACI√ìN
---------------------------------------------
1. Cliente ingresa email/password
2. Backend:
   - Valida credenciales
   - Busca Cliente asociado
   - Verifica EstadoId
   - Como EstadoId == 2 (Activo):
     ‚Ä¢ Genera token JWT con ClienteId
     ‚Ä¢ Login exitoso
3. Frontend:
   - Guarda token
   - Redirige a dashboard de cliente (futuro)

FLUJO 6: ADMIN RECHAZA CLIENTE
-------------------------------
1. Admin en p√°gina de pendientes
2. Click en bot√≥n "Rechazar"
3. Backend:
   - Cambia EstadoId a 3 (Inactivo)
   - Registra quien rechaz√≥
   - NO crea cuenta corriente
4. Frontend:
   - Mensaje: "{Nombre} rechazado"
   - Cliente desaparece de pendientes
   - Si intenta login: "Cuenta inactivada. Contacta al comercio"

================================================================================
VALIDACIONES IMPLEMENTADAS
================================================================================

BACKEND:
‚úì Cliente debe existir para aprobar/rechazar
‚úì No se puede aprobar un cliente ya aprobado
‚úì Usuario debe estar autenticado para aprobar/rechazar
‚úì Al auto-registrarse, comercio debe existir
‚úì Email √∫nico por comercio
‚úì CuentaCorriente se crea solo una vez (valida existencia)
‚úì Login solo permitido para clientes con EstadoId = 2
‚úì Mensajes de error espec√≠ficos por estado:
  - EstadoId 1: "Pendiente de aprobaci√≥n"
  - EstadoId 3: "Cuenta inactivada"

FRONTEND:
‚úì Botones de aprobar/rechazar solo para EstadoId = 1
‚úì Filtros por estado funcionan correctamente
‚úì Recarga autom√°tica despu√©s de aprobar/rechazar
‚úì Mensajes claros de √©xito/error

================================================================================
DECISIONES DE DISE√ëO
================================================================================

1. **Tabla de Estados Extensible**
   ‚úì Por qu√©: Permite agregar nuevos estados en el futuro sin cambiar c√≥digo
   Ejemplos futuros: "Suspendido", "En Revisi√≥n", "Bloqueado"

2. **UsuarioId Nullable en Cliente**
   ‚úì Por qu√©: Permite clientes creados por admin sin usuario inicialmente
   ‚úì Clientes de autogesti√≥n siempre tienen UsuarioId
   ‚úì Clientes de admin pueden tener UsuarioId si se les crea credenciales

3. **Cuenta Corriente en Aprobaci√≥n**
   ‚úì Por qu√©: No tiene sentido tener cuenta si no est√° aprobado
   ‚úì Evita cuentas "fantasma" de clientes rechazados
   ‚úì Admin-created clients: aprobaci√≥n autom√°tica, cuenta inmediata

4. **OrigenRegistro como Int**
   ‚úì Por qu√©: M√°s eficiente que string, extensible
   ‚úì Futuro: agregar origen "Importaci√≥n", "API", etc.

5. **AprobadoPorUsuarioId para Rechazos**
   ‚úì Por qu√©: Mantener auditor√≠a de qui√©n rechaz√≥
   ‚úì √ötil para reportes y seguimiento

6. **ON DELETE RESTRICT en FKs**
   ‚úì Por qu√©: Previene eliminaci√≥n accidental en cascada
   ‚úì Seguridad: no se puede borrar estado si tiene clientes
   ‚úì No se puede borrar usuario que aprob√≥ clientes

7. **P√°gina Separada para Pendientes**
   ‚úì Por qu√©: Mejora UX, admin puede enfocarse en aprobaciones
   ‚úì Alternativa: solo filtro en lista principal tambi√©n disponible

================================================================================
TECNOLOG√çAS Y PATRONES UTILIZADOS
================================================================================

BACKEND:
- Entity Framework Core - Migrations
- ASP.NET Core - Controllers, Authorization
- Repository Pattern
- Service Layer Pattern
- DTO Pattern
- Dependency Injection
- JWT Claims para autorizaci√≥n
- Soft Delete Pattern
- State Machine Pattern (EstadoCliente)

FRONTEND:
- Blazor WebAssembly
- MudBlazor:
  ‚Ä¢ MudTable
  ‚Ä¢ MudChip (estados y or√≠genes)
  ‚Ä¢ MudSelect (filtros)
  ‚Ä¢ MudButton
  ‚Ä¢ MudSnackbar (notificaciones)
  ‚Ä¢ MudProgressCircular
  ‚Ä¢ MudAlert
- Component-based architecture
- Async/await pattern
- HttpClient para API calls

BASE DE DATOS:
- SQL Server LocalDB
- Foreign Keys con constraints
- Indexes en FK para performance
- Data seeding
- Data migration scripts

================================================================================
TESTING
================================================================================

COMPILACI√ìN:
‚úì Build exitoso sin errores
‚ö† Warnings menores (nullable references, MudBlazor deprecations)

MIGRACI√ìN:
‚úì Migration aplicada correctamente
‚úì Datos existentes migrados (EstadoId=2, OrigenRegistro=2)
‚úì Tablas creadas
‚úì Foreign keys establecidas
‚úì √çndices creados

PRUEBAS MANUALES RECOMENDADAS:
1. ‚úì Crear cliente desde admin
   - Verificar EstadoId = 2
   - Verificar cuenta corriente creada
   - Verificar origen "Administraci√≥n"

2. ‚úì Auto-registro de cliente
   - Verificar EstadoId = 1
   - Verificar NO tiene cuenta corriente
   - Verificar origen "Autogesti√≥n"
   - Verificar UsuarioId est√° establecido

3. ‚úì Login con cliente pendiente
   - Verificar mensaje de error apropiado
   - Verificar que no se genera token

4. ‚úì Aprobar cliente
   - Verificar cambio de estado a Activo
   - Verificar creaci√≥n de cuenta corriente
   - Verificar FechaAprobacion
   - Verificar AprobadoPorUsuarioId

5. ‚úì Login con cliente aprobado
   - Verificar token generado
   - Verificar claim ClienteId en token

6. ‚úì Rechazar cliente
   - Verificar cambio de estado a Inactivo
   - Verificar NO se crea cuenta corriente

7. ‚úì Filtros en lista de clientes
   - Todos, Pendientes, Activos, Inactivos

8. ‚úì P√°gina de pendientes
   - Listar solo pendientes
   - Aprobar desde p√°gina
   - Rechazar desde p√°gina

================================================================================
PR√ìXIMOS PASOS SUGERIDOS
================================================================================

FUNCIONALIDAD:
‚ñ° Notificaciones al comercio cuando hay nuevo pendiente
‚ñ° Email al cliente cuando es aprobado/rechazado
‚ñ° Permitir al cliente cambiar su password
‚ñ° Dashboard para clientes aprobados
‚ñ° Historial de aprobaciones/rechazos
‚ñ° Raz√≥n de rechazo (campo adicional)
‚ñ° Re-activaci√≥n de clientes rechazados
‚ñ° Bulk approval (aprobar m√∫ltiples a la vez)

SEGURIDAD:
‚ñ° Rate limiting en auto-registro
‚ñ° CAPTCHA en formulario de auto-registro
‚ñ° Verificaci√≥n de email antes de aprobar
‚ñ° Logs de auditor√≠a de aprobaciones

UX/UI:
‚ñ° Notificaci√≥n badge en men√∫ con cantidad de pendientes
‚ñ° Confirmaci√≥n antes de rechazar
‚ñ° Raz√≥n de rechazo (textarea)
‚ñ° Filtro combinado (estado + origen)
‚ñ° Exportar lista de pendientes
‚ñ° Vista previa de cliente antes de aprobar

T√âCNICO:
‚ñ° Unit tests de AprobacionService
‚ñ° Integration tests de endpoints
‚ñ° Tests de migraci√≥n de datos
‚ñ° Performance test con muchos clientes
‚ñ° Logging estructurado de aprobaciones
‚ñ° M√©tricas: tiempo promedio de aprobaci√≥n

================================================================================
NOTAS IMPORTANTES
================================================================================

‚Ä¢ Los clientes creados por admin se aprueban autom√°ticamente
‚Ä¢ Los clientes auto-registrados quedan pendientes
‚Ä¢ La cuenta corriente se crea SOLO al aprobar
‚Ä¢ Clientes pendientes o inactivos NO pueden hacer login
‚Ä¢ El sistema registra qui√©n aprob√≥/rechaz√≥ cada cliente
‚Ä¢ Estados son extensibles (f√°cil agregar nuevos)
‚Ä¢ Origen es extensible (futuro: importaci√≥n, API, etc.)
‚Ä¢ Todos los clientes existentes fueron marcados como Autogesti√≥n/Activo
‚Ä¢ Usuario.Apellido fue a√±adido para soportar rol Cliente
‚Ä¢ Usuario.Rol ahora incluye "Cliente" adem√°s de Admin/Usuario/SuperAdmin
‚Ä¢ Foreign Keys tienen ON DELETE RESTRICT para seguridad
‚Ä¢ AprobadoPorUsuarioId se usa tanto para aprobaci√≥n como rechazo (auditor√≠a)

ARQUITECTURA:
‚Ä¢ Cliente.UsuarioId nullable permite clientes sin credenciales (creados por admin)
‚Ä¢ Clientes de autogesti√≥n SIEMPRE tienen UsuarioId
‚Ä¢ Sistema de autenticaci√≥n unificado en tabla Usuario
‚Ä¢ No hay duplicaci√≥n de l√≥gica de passwords
‚Ä¢ F√°cil extender a otros roles en el futuro

FLUJO CR√çTICO:
1. Auto-registro ‚Üí Usuario creado + Cliente creado (EstadoId=1, sin cuenta)
2. Login pendiente ‚Üí ERROR: "Pendiente de aprobaci√≥n"
3. Admin aprueba ‚Üí EstadoId=2, cuenta corriente creada
4. Login aprobado ‚Üí SUCCESS: Token generado con ClienteId

================================================================================
FIN DEL RESUMEN
================================================================================
