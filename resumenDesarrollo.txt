================================================================================
RESUMEN DE DESARROLLO - SaaS Cuentas Corrientes
================================================================================
Fecha: 2025-12-04
Branch actual: hardcore-wright

================================================================================
√öLTIMA IMPLEMENTACI√ìN: Refactorizaci√≥n Cliente Multicomercio
================================================================================
Fecha: 2025-12-04
Branch: hardcore-wright

DESCRIPCI√ìN:
------------
Se refactoriz√≥ completamente el modelo de datos para permitir que un usuario
(persona f√≠sica con email √∫nico) pueda ser cliente de m√∫ltiples comercios,
manteniendo un solo login y m√∫ltiples vinculaciones independientes.

OBJETIVO LOGRADO:
-----------------
‚úì Un usuario con email √∫nico puede ser cliente de m√∫ltiples comercios
‚úì Un solo login (email + contrase√±a) para acceder a todos sus comercios
‚úì Cada vinculaci√≥n (Cliente) tiene su propio estado de aprobaci√≥n
‚úì Cada vinculaci√≥n tiene su propia cuenta corriente
‚úì Usuario.ComercioId = null para clientes (se relacionan v√≠a tabla Cliente)
‚úì Cliente act√∫a como tabla intermedia entre Usuario y Comercio

MODELO ANTES:
-------------
Usuario (ComercioId NOT NULL) 1:1 ‚Üí Comercio
Usuario (email √∫nico) 1:N ‚Üí Cliente (pero solo 1 activo por comercio)
Problema: No se pod√≠a crear otro Usuario con el mismo email

MODELO DESPU√âS:
---------------
Usuario (ComercioId nullable) 0..1 ‚Üí Comercio (solo para Admin/UsuarioComercio)
Usuario (email √∫nico) 1:N ‚Üí Cliente (m√∫ltiples activos) N:1 ‚Üí Comercio

Cliente ahora es tabla intermedia:
Cliente {
  UsuarioId (required FK)
  ComercioId (required FK)
  EstadoId
  CuentaCorriente (1:1)
  Alias, NotasComercio (datos espec√≠ficos de esta vinculaci√≥n)
}

================================================================================
ARCHIVOS CREADOS
================================================================================

1. PLAN_REFACTOR_CLIENTE_MULTICOMERCIO.md
   - Plan detallado de la refactorizaci√≥n
   - Modelo antes/despu√©s
   - Flujos de usuario
   - Checklist de implementaci√≥n

================================================================================
ARCHIVOS MODIFICADOS
================================================================================

ENTIDADES (SaasACC.Model/Entities/):
------------------------------------

1. Usuario.cs
   - ComercioId: int ‚Üí int? (nullable)
   - Navegaci√≥n Comercio: Comercio ‚Üí Comercio? (nullable)
   - Nueva colecci√≥n: ICollection<Cliente> Clientes (vinculaciones del usuario)
   - Mantiene ICollection<Cliente> ClientesAprobados (para auditor√≠a)

2. Cliente.cs
   - UsuarioId: int? ‚Üí int (REQUIRED, no nullable)
   - Nuevos campos opcionales:
     * string? Alias - Ej: "Juan el del taller"
     * string? NotasComercio - Notas privadas del comercio sobre este cliente
   - Navegaci√≥n Usuario: Usuario? ‚Üí Usuario (required)
   - Comentarios actualizados indicando que Cliente es tabla intermedia

CONFIGURACI√ìN DE BASE DE DATOS (SaasACC.Infrastructure/):
----------------------------------------------------------

3. ApplicationDbContext.cs

   ConfigurarUsuario():
   - Usuario.ComercioId ‚Üí .IsRequired(false) // NULLABLE
   - Relaci√≥n Usuario ‚Üí Comercio ‚Üí .IsRequired(false)
   - Email √∫nico GLOBAL se mantiene

   ConfigurarCliente():
   - Nuevas propiedades:
     * Alias ‚Üí .HasMaxLength(100)
     * NotasComercio ‚Üí .HasMaxLength(500)

   - Relaci√≥n Usuario ‚Üí Cliente:
     * .HasOne(c => c.Usuario).WithMany(u => u.Clientes)
     * .IsRequired(true) // UsuarioId es REQUIRED

   - √çNDICE √öNICO NUEVO:
     * entity.HasIndex(c => new { c.UsuarioId, c.ComercioId }).IsUnique()
     * Un usuario solo puede ser cliente una vez por comercio

   - MANTIENE √≠ndice Email+Comercio por compatibilidad

REPOSITORIOS (SaasACC.Application/Interfaces/ y SaasACC.Infrastructure/Repositories/):
--------------------------------------------------------------------------------------

4. IClienteRepository.cs
   Nuevos m√©todos:
   - Task<IEnumerable<Cliente>> GetByUsuarioIdAsync(int usuarioId)
   - Task<bool> ExisteVinculoAsync(int usuarioId, int comercioId)
   - Task<Cliente?> GetVinculoAsync(int usuarioId, int comercioId)

5. ClienteRepository.cs
   Implementaci√≥n de nuevos m√©todos:
   - GetByUsuarioIdAsync: Obtiene todas las vinculaciones (clientes) de un usuario
   - ExisteVinculoAsync: Verifica si ya existe vinculaci√≥n Usuario-Comercio
   - GetVinculoAsync: Obtiene vinculaci√≥n espec√≠fica con navegaciones

SERVICIOS (SaasACC.Application/Services/):
-------------------------------------------

6. ClienteService.cs

   CreateClienteAsync() - REFACTORIZADO:
   - Busca si usuario ya existe por email
   - Si existe: verifica que no est√© ya vinculado al comercio, reutiliza usuario
   - Si no existe: crea nuevo usuario con ComercioId = null (para clientes)
   - Crea vinculaci√≥n Cliente (tabla intermedia)
   - Permite que un comercio agregue cliente que ya existe en otro comercio

   Constructor - MODIFICADO:
   - Nuevo par√°metro: IComercioRepository _comercioRepository

   Nuevos m√©todos:
   - GetComerciosDeUsuarioAsync(int usuarioId)
     * Retorna lista de comercios donde el usuario es cliente
     * Incluye: ComercioId, Nombre, EstadoId, Saldo, FechaVinculaci√≥n

   - VincularUsuarioAComercioAsync(int usuarioId, int comercioId, bool requiereAprobacion)
     * Permite que un usuario se vincule a un nuevo comercio
     * Valida que usuario y comercio existan
     * Valida que no est√© ya vinculado
     * Crea nueva vinculaci√≥n Cliente
     * Si no requiere aprobaci√≥n, crea cuenta corriente inmediatamente

7. AuthService.cs

   LoginAsync() - REFACTORIZADO:
   - Para clientes: obtiene TODAS sus vinculaciones activas (EstadoId = 2)
   - Valida que tenga al menos un comercio activo
   - Genera token con claim "ComercioIds" (lista separada por comas)
   - Retorna lista de comercios en LoginResponse.Comercios

   RegisterClienteAsync() - REFACTORIZADO:
   - Busca si usuario ya existe por email
   - Si existe: valida contrase√±a y verifica que no est√© ya en ese comercio
   - Si no existe: crea nuevo usuario con ComercioId = null
   - Crea vinculaci√≥n Cliente (EstadoId = 1 Pendiente)
   - Permite que un usuario existente se registre en otro comercio

   GenerateJwtTokenAsync() - REFACTORIZADO:
   - Firma: (Usuario usuario, List<ComercioInfo>? comercios = null)
   - Para Admin/UsuarioComercio: agrega claim "ComercioId" (√∫nico)
   - Para Cliente: agrega claim "ComercioIds" (lista: "1,2,3")

DTOs (SaasACC.Model/DTOs/):
----------------------------

8. ClienteDto.cs
   Nuevo DTO:
   - MiComercioDto: Para listar comercios del usuario
     * ComercioId, NombreComercio
     * EstadoId, EstadoNombre
     * FechaVinculacion, FechaAprobacion
     * Saldo

9. LoginResponse.cs (SaasACC.Model/Servicios/Login/)
   - Nuevo campo: List<ComercioInfo>? Comercios
   - Nueva clase: ComercioInfo { int Id, string Nombre }

CONTROLADORES (SaasACCAPI.api/Controllers/):
---------------------------------------------

10. ClientesController.cs

    Nuevos endpoints:

    GET /api/clientes/mis-comercios
    - Autorizaci√≥n: [Authorize(Roles = "Cliente")]
    - Retorna: IEnumerable<MiComercioDto>
    - Descripci√≥n: Obtiene todos los comercios donde el usuario autenticado es cliente

    POST /api/clientes/vincular
    - Autorizaci√≥n: [Authorize(Roles = "Cliente")]
    - Body: VincularComercioRequest { ComercioId, RequiereAprobacion }
    - Retorna: ClienteDto
    - Descripci√≥n: Vincula al usuario autenticado a un nuevo comercio

    Nueva clase:
    - VincularComercioRequest { int ComercioId, bool RequiereAprobacion = true }

================================================================================
FLUJOS DE USUARIO IMPLEMENTADOS
================================================================================

FLUJO 1: Cliente se vincula a otro comercio
--------------------------------------------
1. Juan (usuario existente, cliente de Comercio A) hace login
2. Ve sus comercios: GET /api/clientes/mis-comercios
3. Selecciona "Vincularme a otro comercio"
4. POST /api/clientes/vincular { comercioId: 2, requiereAprobacion: true }
5. Sistema:
   - Valida que Juan no est√© ya vinculado a Comercio B
   - Crea Cliente (UsuarioId=Juan, ComercioId=2, EstadoId=1 Pendiente)
6. Admin de Comercio B ve cliente pendiente
7. POST /api/clientes/{id}/aprobar
8. Sistema crea CuentaCorriente para Comercio B
9. Juan ahora puede operar en ambos comercios

FLUJO 2: Comercio agrega cliente existente
-------------------------------------------
1. Admin de Comercio B: "Agregar cliente"
2. Ingresa email: juan@example.com (ya es cliente de Comercio A)
3. POST /api/clientes { email: "juan@example.com", nombre: "Juan", ... }
4. Sistema:
   - Busca usuario por email ‚Üí ENCUENTRA a Juan
   - Verifica que no est√© ya en Comercio B
   - Crea vinculaci√≥n Cliente (UsuarioId existente, ComercioId=2, EstadoId=2 Activo)
   - Crea CuentaCorriente para Comercio B
5. Juan puede operar inmediatamente en Comercio B
6. Pr√≥ximo login de Juan: ver√° ambos comercios en la lista

FLUJO 3: Login con m√∫ltiples comercios
---------------------------------------
1. Juan hace login con juan@example.com
2. Sistema:
   - Busca usuario
   - Obtiene vinculaciones: Cliente(Comercio A, Activo), Cliente(Comercio B, Activo)
   - Genera token con claim "ComercioIds: 1,2"
3. Retorna LoginResponse:
   {
     "token": "...",
     "comercios": [
       { "id": 1, "nombre": "Ferreter√≠a L√≥pez" },
       { "id": 2, "nombre": "Farmacia P√©rez" }
     ]
   }
4. Frontend muestra selector de comercio
5. Juan selecciona y opera en el contexto elegido

FLUJO 4: Autogesti√≥n con usuario existente
-------------------------------------------
1. Juan (ya cliente de Comercio A) quiere registrarse en Comercio C
2. POST /api/auth/register/cliente
   {
     "email": "juan@example.com",
     "password": "suPassword",
     "comercioId": 3,
     ...
   }
3. Sistema:
   - Busca usuario por email ‚Üí ENCUENTRA a Juan
   - Valida contrase√±a (debe ser la misma)
   - Verifica que no est√© ya en Comercio C
   - Crea vinculaci√≥n Cliente (EstadoId=1 Pendiente)
4. Retorna: "Pendiente de aprobaci√≥n por el comercio"
5. Admin de Comercio C aprueba
6. Juan puede acceder a Comercio C

================================================================================
CAMBIOS EN LA BASE DE DATOS (Para migraci√≥n)
================================================================================

MODIFICACIONES EN TABLAS:
--------------------------

1. Tabla Usuarios:
   - ComercioId: Cambiar a NULLABLE (de INT NOT NULL a INT NULL)
   - Raz√≥n: Clientes no tienen ComercioId (se relacionan v√≠a Cliente)

2. Tabla Clientes:
   - UsuarioId: Cambiar a NOT NULL (de INT NULL a INT NOT NULL)
   - Nuevas columnas:
     * Alias NVARCHAR(100) NULL
     * NotasComercio NVARCHAR(500) NULL

√çNDICES:
--------

1. NUEVO: IX_Clientes_UsuarioId_ComercioId (UNIQUE)
   - Garantiza: Un usuario solo puede ser cliente una vez por comercio
   - CREATE UNIQUE INDEX IX_Clientes_UsuarioId_ComercioId ON Clientes (UsuarioId, ComercioId)

2. MANTIENE: IX_Clientes_ComercioId_Email (UNIQUE)
   - Por compatibilidad con l√≥gica existente

================================================================================
VALIDACIONES IMPLEMENTADAS
================================================================================

1. CreateClienteAsync (ClienteService):
   ‚úì Si usuario existe: verifica que no est√© ya vinculado al comercio
   ‚úì Si usuario NO existe: valida que DNI est√© presente
   ‚úì Permite reutilizar usuario existente

2. VincularUsuarioAComercioAsync (ClienteService):
   ‚úì Valida que usuario exista
   ‚úì Valida que comercio exista
   ‚úì Valida que no est√© ya vinculado

3. RegisterClienteAsync (AuthService):
   ‚úì Si usuario existe: valida contrase√±a
   ‚úì Verifica que no est√© ya vinculado al comercio
   ‚úì Permite mismo usuario en m√∫ltiples comercios

4. LoginAsync (AuthService):
   ‚úì Obtiene todas las vinculaciones activas del usuario
   ‚úì Valida que tenga al menos un comercio activo
   ‚úì Retorna lista de comercios disponibles

================================================================================
DECISIONES DE DISE√ëO IMPORTANTES
================================================================================

1. MANTENER datos personales en Cliente (por ahora)
   - Nombre, Apellido, Email, Tel√©fono, DNI, Direcci√≥n
   - Raz√≥n: Evitar romper l√≥gica existente
   - Futura mejora: Mover a Usuario para evitar duplicaci√≥n

2. Usuario.ComercioId NULLABLE
   - NULL para Rol="Cliente"
   - NOT NULL para Rol="Admin" o "UsuarioComercio"
   - Permite diferenciar tipos de usuario

3. Cliente como tabla intermedia
   - No crear nueva tabla "ClienteComercio"
   - Cliente YA cumple ese rol perfectamente
   - Simplifica el modelo

4. √çndice √∫nico {UsuarioId, ComercioId}
   - Garantiza integridad de datos
   - Evita vinculaciones duplicadas
   - Base de datos asegura la restricci√≥n

5. Alias y NotasComercio en Cliente
   - Datos espec√≠ficos de cada vinculaci√≥n
   - Comercio puede personalizar c√≥mo ve al cliente
   - No afecta al usuario en otros comercios

================================================================================
ENDPOINTS NUEVOS
================================================================================

GET /api/clientes/mis-comercios
POST /api/clientes/vincular

================================================================================
PR√ìXIMOS PASOS (En otra PC con BD)
================================================================================

1. Hacer pull del repositorio

2. Crear y aplicar migraci√≥n:
   cd SaasACC.Infrastructure
   dotnet ef migrations add RefactorClienteMultiComercio --startup-project ../SaasACCAPI.api
   dotnet ef database update --startup-project ../SaasACCAPI.api

3. Verificar cambios en BD:
   - Usuario.ComercioId permite NULL
   - Cliente.UsuarioId es NOT NULL
   - Nuevas columnas: Alias, NotasComercio
   - √çndice √∫nico: IX_Clientes_UsuarioId_ComercioId

4. Actualizar frontend (si existe):
   - Login: Mostrar selector de comercios si Comercios.Count > 1
   - Agregar opci√≥n "Vincularme a otro comercio"
   - Usar claim "ComercioIds" del token

================================================================================
TECNOLOG√çAS UTILIZADAS
================================================================================

- .NET 8
- Entity Framework Core (Code First con migraciones)
- SQL Server LocalDB
- JWT Authentication
- ASP.NET Core Web API

================================================================================
NOTAS IMPORTANTES
================================================================================

1. NO se ejecut√≥ migraci√≥n en esta m√°quina (no tiene BD)
2. Migraci√≥n lista para ejecutar en otra PC
3. C√≥digo compatible con modelo anterior ANTES de migraci√≥n
4. Despu√©s de migraci√≥n, nuevos flujos quedan disponibles
5. Plan detallado en: PLAN_REFACTOR_CLIENTE_MULTICOMERCIO.md

================================================================================
TESTING RECOMENDADO
================================================================================

Despu√©s de aplicar migraci√≥n, testear:

1. ‚úì Cliente nuevo se registra por autogesti√≥n
2. ‚úì Cliente existente se vincula a nuevo comercio (autogesti√≥n)
3. ‚úì Comercio agrega cliente que ya existe en otro comercio
4. ‚úì Login con m√∫ltiples comercios muestra lista
5. ‚úì Operaciones en cada comercio son independientes
6. ‚úì Cuentas corrientes separadas por comercio
7. ‚úì Estados de aprobaci√≥n independientes por comercio

================================================================================

================================================================================
IMPLEMENTACI√ìN ANTERIOR: Sistema de Registro con Dos Botones Separados
================================================================================

DESCRIPCI√ìN:
------------
Se implement√≥ un sistema completo de registro que permite crear cuentas de dos
tipos diferentes: Comercios y Clientes. La soluci√≥n utiliza DOS BOTONES
SEPARADOS en la interfaz de registro para proporcionar claridad inmediata al
usuario sobre qu√© tipo de cuenta desea crear.

DECISI√ìN DE DISE√ëO:
-------------------
‚úì DOS BOTONES SEPARADOS (Implementado)
  - Bot√≥n 1: "Registrar Comercio" - Para negocios
  - Bot√≥n 2: "Registrar Cliente" - Para clientes de comercios existentes

  Ventajas:
  ‚Ä¢ Claridad inmediata sobre qu√© se va a crear
  ‚Ä¢ Menos pasos en el flujo de registro
  ‚Ä¢ Mejor UX para perfiles claramente diferenciados
  ‚Ä¢ No hay ambig√ºedad ni decisiones adicionales

‚úó UN SOLO BOT√ìN + SELECT (Rechazado)
  - Requiere pasos adicionales
  - Mayor fricci√≥n en el proceso

================================================================================
ARCHIVOS CREADOS/MODIFICADOS
================================================================================

BACKEND - API (.NET 8)
----------------------

NUEVOS ARCHIVOS:
1. SaasACC.Model/Servicios/Login/RegisterComercioRequest.cs
   - DTO para registro de comercio
   - Validaciones: nombre, email, tel√©fono, direcci√≥n del comercio
   - Datos del administrador: nombre, email, password con confirmaci√≥n

2. SaasACC.Model/Servicios/Login/RegisterClienteRequest.cs
   - DTO para registro de cliente
   - Validaciones: nombre, apellido, email, tel√©fono
   - Campos opcionales: DNI, direcci√≥n
   - Referencia a ComercioId

3. SaasACC.Model/Servicios/Login/RegisterResponse.cs
   - Respuesta unificada para ambos tipos de registro
   - Incluye: Success, Message, Token, ComercioId, ClienteId, ErrorMessage

4. SaasACC.Application/Interfaces/IComercioRepository.cs
   - Interfaz del repositorio de comercios
   - M√©todos: GetByIdAsync, GetByEmailAsync, GetAllAsync, CreateAsync, etc.

5. SaasACC.Infrastructure/Repositories/ComercioRepository.cs
   - Implementaci√≥n del repositorio de comercios
   - CRUD completo con validaciones
   - Soft delete implementado

6. SaasACCAPI.api/Controllers/ComerciosController.cs
   - Endpoint GET /api/comercios - Lista comercios activos
   - Retorna ComercioDto simplificado

ARCHIVOS MODIFICADOS:
1. SaasACC.Application/Services/AuthService.cs
   - A√±adida interfaz IAuthService:
     ‚Ä¢ RegisterComercioAsync(RegisterComercioRequest)
     ‚Ä¢ RegisterClienteAsync(RegisterClienteRequest)

   - Implementaci√≥n RegisterComercioAsync:
     ‚Ä¢ Valida email del comercio √∫nico
     ‚Ä¢ Valida email del administrador √∫nico
     ‚Ä¢ Crea comercio
     ‚Ä¢ Crea usuario administrador con rol "Admin"
     ‚Ä¢ Genera token JWT autom√°ticamente

   - Implementaci√≥n RegisterClienteAsync:
     ‚Ä¢ Valida que el comercio existe
     ‚Ä¢ Valida email √∫nico dentro del comercio
     ‚Ä¢ Crea cliente
     ‚Ä¢ Crea cuenta corriente autom√°ticamente

   - A√±adido m√©todo HashPassword (SHA256)

2. SaasACC.Application/Interfaces/IUsuarioRepository.cs
   - A√±adido m√©todo: CreateAsync(Usuario)

3. SaasACC.Infrastructure/Repositories/UsuarioRepository.cs
   - Implementado m√©todo CreateAsync
   - Establece FechaCreacion y Activo autom√°ticamente

4. SaasACCAPI.api/Controllers/AuthController.cs
   - Endpoint POST /api/auth/register/comercio
     ‚Ä¢ Valida ModelState
     ‚Ä¢ Logging de intentos y resultados
     ‚Ä¢ Retorna RegisterResponse con token

   - Endpoint POST /api/auth/register/cliente
     ‚Ä¢ Valida ModelState
     ‚Ä¢ Logging de intentos y resultados
     ‚Ä¢ Retorna RegisterResponse

5. SaasACCAPI.api/Program.cs
   - Registrado IComercioRepository en DI container
   - L√≠nea a√±adida: builder.Services.AddScoped<IComercioRepository, ComercioRepository>();

FRONTEND - BLAZOR WASM
----------------------

NUEVOS ARCHIVOS:
1. SaasACC.BlazorWasm/Pages/Auth/Register.razor
   - P√°gina principal de registro
   - DOS BOTONES CLARAMENTE DIFERENCIADOS:
     ‚Ä¢ Bot√≥n Primary: "Registrar Comercio" con icono Business
       ‚îî‚îÄ Descripci√≥n: "Para negocios que desean gestionar cuentas corrientes"
     ‚Ä¢ Bot√≥n Outlined: "Registrar Cliente" con icono Person
       ‚îî‚îÄ Descripci√≥n: "Para clientes con cuenta en un comercio existente"
   - Link a login para usuarios existentes
   - Layout: EmptyLayout (sin men√∫s de navegaci√≥n)

2. SaasACC.BlazorWasm/Pages/Auth/RegisterComercio.razor
   - Formulario completo de registro de comercio
   - Secci√≥n 1 - Datos del Comercio:
     ‚Ä¢ Nombre del comercio (requerido)
     ‚Ä¢ Email del comercio (requerido, validaci√≥n email)
     ‚Ä¢ Tel√©fono (requerido)
     ‚Ä¢ Direcci√≥n (requerido, multilinea)

   - Secci√≥n 2 - Datos del Administrador:
     ‚Ä¢ Nombre del administrador (requerido)
     ‚Ä¢ Email del administrador (requerido)
     ‚Ä¢ Password (requerido, con toggle visibilidad)
     ‚Ä¢ Confirmar password (requerido, validaci√≥n coincidencia)

   - Validaciones en tiempo real con MudBlazor
   - Bot√≥n de env√≠o con loading spinner
   - Bot√≥n "Volver" a selecci√≥n de tipo
   - Al registrar exitosamente: redirige a /admin/clientes

3. SaasACC.BlazorWasm/Pages/Auth/RegisterCliente.razor
   - Formulario de registro de cliente
   - Carga lista de comercios desde API en OnInitializedAsync
   - Dropdown para seleccionar comercio
   - Campos del cliente:
     ‚Ä¢ Nombre (requerido)
     ‚Ä¢ Apellido (requerido)
     ‚Ä¢ Email (requerido)
     ‚Ä¢ Tel√©fono (requerido)
     ‚Ä¢ DNI (opcional)
     ‚Ä¢ Direcci√≥n (opcional)

   - Loading spinner mientras carga comercios
   - Validaciones integradas
   - Al registrar: muestra mensaje de √©xito y redirige a /login

ARCHIVOS MODIFICADOS:
1. SaasACC.BlazorWasm/Services/IAuthService.cs
   - A√±adidos m√©todos a la interfaz:
     ‚Ä¢ RegisterComercio(RegisterComercioRequest)
     ‚Ä¢ RegisterCliente(RegisterClienteRequest)

2. SaasACC.BlazorWasm/Services/AuthService.cs
   - Implementado RegisterComercio:
     ‚Ä¢ POST a api/auth/register/comercio
     ‚Ä¢ Si exitoso: guarda token, role "Admin", comercioId en localStorage
     ‚Ä¢ Notifica a AuthStateProvider
     ‚Ä¢ Retorna RegisterResponse

   - Implementado RegisterCliente:
     ‚Ä¢ POST a api/auth/register/cliente
     ‚Ä¢ No guarda token (solo registro, no login autom√°tico)
     ‚Ä¢ Retorna RegisterResponse

3. SaasACC.BlazorWasm/Pages/Auth/Login.razor
   - A√±adido link de registro despu√©s del bot√≥n de login:
     ‚Ä¢ "¬øNo tienes cuenta?"
     ‚Ä¢ Link: "Crear cuenta" ‚Üí /register
   - Separador visual (MudDivider)

================================================================================
FLUJO DE USUARIO IMPLEMENTADO
================================================================================

1. INICIO EN LOGIN
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ   Login.razor       ‚îÇ
   ‚îÇ  Email / Password   ‚îÇ
   ‚îÇ  [Iniciar Sesi√≥n]   ‚îÇ
   ‚îÇ                     ‚îÇ
   ‚îÇ  ¬øNo tienes cuenta? ‚îÇ
   ‚îÇ  ‚Üí Crear cuenta     ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
                               ‚ñº
2. SELECCI√ìN DE TIPO DE CUENTA
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ       Register.razor                 ‚îÇ
   ‚îÇ                                      ‚îÇ
   ‚îÇ  [Registrar Comercio] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
   ‚îÇ   üìä Para negocios              ‚îÇ    ‚îÇ
   ‚îÇ                                 ‚îÇ    ‚îÇ
   ‚îÇ  [Registrar Cliente] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ    ‚îÇ
   ‚îÇ   üë§ Para clientes          ‚îÇ   ‚îÇ    ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ   ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ                                          ‚îÇ
         ‚ñº                                          ‚ñº
3A. REGISTRO COMERCIO              3B. REGISTRO CLIENTE
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇRegisterComercio     ‚îÇ           ‚îÇRegisterCliente      ‚îÇ
   ‚îÇ                     ‚îÇ           ‚îÇ                     ‚îÇ
   ‚îÇ Datos Comercio:     ‚îÇ           ‚îÇ Seleccionar:        ‚îÇ
   ‚îÇ ‚Ä¢ Nombre            ‚îÇ           ‚îÇ ‚Ä¢ Comercio (dropdown)‚îÇ
   ‚îÇ ‚Ä¢ Email             ‚îÇ           ‚îÇ                     ‚îÇ
   ‚îÇ ‚Ä¢ Tel√©fono          ‚îÇ           ‚îÇ Tus Datos:          ‚îÇ
   ‚îÇ ‚Ä¢ Direcci√≥n         ‚îÇ           ‚îÇ ‚Ä¢ Nombre            ‚îÇ
   ‚îÇ                     ‚îÇ           ‚îÇ ‚Ä¢ Apellido          ‚îÇ
   ‚îÇ Datos Admin:        ‚îÇ           ‚îÇ ‚Ä¢ Email             ‚îÇ
   ‚îÇ ‚Ä¢ Nombre            ‚îÇ           ‚îÇ ‚Ä¢ Tel√©fono          ‚îÇ
   ‚îÇ ‚Ä¢ Email             ‚îÇ           ‚îÇ ‚Ä¢ DNI (opcional)    ‚îÇ
   ‚îÇ ‚Ä¢ Password          ‚îÇ           ‚îÇ ‚Ä¢ Direcci√≥n (opc)   ‚îÇ
   ‚îÇ ‚Ä¢ Confirmar Pass    ‚îÇ           ‚îÇ                     ‚îÇ
   ‚îÇ                     ‚îÇ           ‚îÇ                     ‚îÇ
   ‚îÇ [Crear Cuenta]      ‚îÇ           ‚îÇ [Crear Cuenta]      ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ                                 ‚îÇ
          ‚îÇ                                 ‚îÇ
          ‚ñº                                 ‚ñº
   API: POST /auth/register/comercio   API: POST /auth/register/cliente
   ‚Ä¢ Crea Comercio                     ‚Ä¢ Valida Comercio existe
   ‚Ä¢ Crea Usuario Admin                ‚Ä¢ Crea Cliente
   ‚Ä¢ Hash password (SHA256)            ‚Ä¢ Crea CuentaCorriente
   ‚Ä¢ Genera JWT Token                  ‚Ä¢ Sin login autom√°tico
          ‚îÇ                                 ‚îÇ
          ‚ñº                                 ‚ñº
   Guarda token en localStorage        Mensaje de √©xito
   Redirige: /admin/clientes          Redirige: /login

================================================================================
ENDPOINTS API CREADOS
================================================================================

1. POST /api/auth/register/comercio
   Request Body: RegisterComercioRequest
   {
     "nombreComercio": "string",
     "emailComercio": "string",
     "telefonoComercio": "string",
     "direccionComercio": "string",
     "nombreAdmin": "string",
     "emailAdmin": "string",
     "password": "string",
     "confirmPassword": "string"
   }

   Response: RegisterResponse
   {
     "success": true,
     "message": "Comercio registrado exitosamente",
     "token": "eyJhbGc...",
     "comercioId": 1,
     "clienteId": null,
     "errorMessage": ""
   }

   C√≥digos HTTP:
   - 200 OK: Registro exitoso
   - 400 Bad Request: Datos inv√°lidos o email duplicado
   - 500 Internal Server Error: Error del servidor

2. POST /api/auth/register/cliente
   Request Body: RegisterClienteRequest
   {
     "nombre": "string",
     "apellido": "string",
     "email": "string",
     "telefono": "string",
     "dni": "string (opcional)",
     "direccion": "string (opcional)",
     "comercioId": 1,
     "password": "string (opcional, futuro)",
     "confirmPassword": "string (opcional, futuro)"
   }

   Response: RegisterResponse
   {
     "success": true,
     "message": "Cliente registrado exitosamente",
     "token": "",
     "comercioId": 1,
     "clienteId": 5,
     "errorMessage": ""
   }

   C√≥digos HTTP:
   - 200 OK: Registro exitoso
   - 400 Bad Request: Comercio no existe o email duplicado
   - 500 Internal Server Error: Error del servidor

3. GET /api/comercios
   Response: Array<ComercioDto>
   [
     {
       "id": 1,
       "nombre": "Mi Comercio",
       "email": "contacto@micomercio.com",
       "telefono": "+54 9 11 1234-5678"
     }
   ]

   C√≥digos HTTP:
   - 200 OK: Lista obtenida exitosamente
   - 500 Internal Server Error: Error del servidor

================================================================================
ESTRUCTURA DE BASE DE DATOS
================================================================================

TABLAS INVOLUCRADAS:

1. Comercios
   - Id (PK)
   - Nombre
   - Email (√∫nico)
   - Telefono
   - Direccion
   - Logo (nullable)
   - NotificacionesEmail
   - NotificacionesWhatsApp
   - FechaCreacion
   - FechaModificacion (nullable)
   - Activo (soft delete)

2. Usuarios
   - Id (PK)
   - Nombre
   - Email
   - PasswordHash (SHA256)
   - Rol ("Admin", "Usuario", "SuperAdmin")
   - ComercioId (FK ‚Üí Comercios)
   - UltimoAcceso (nullable)
   - FechaCreacion
   - FechaModificacion (nullable)
   - Activo (soft delete)

3. Clientes
   - Id (PK)
   - Nombre
   - Apellido
   - Email
   - Telefono
   - DNI (nullable)
   - Direccion (nullable)
   - ComercioId (FK ‚Üí Comercios)
   - FechaCreacion
   - FechaModificacion (nullable)
   - Activo (soft delete)

4. CuentasCorrientes (creada autom√°ticamente al registrar cliente)
   - Id (PK)
   - ClienteId (FK ‚Üí Clientes)
   - LimiteCredito
   - Bloqueada
   - Observaciones (nullable)
   - FechaCreacion
   - FechaModificacion (nullable)
   - Activo (soft delete)

RELACIONES:
- Comercio 1:N Usuarios
- Comercio 1:N Clientes
- Cliente 1:1 CuentaCorriente

================================================================================
TECNOLOG√çAS UTILIZADAS
================================================================================

BACKEND:
- .NET 8
- ASP.NET Core Web API
- Entity Framework Core
- SQL Server LocalDB
- JWT Bearer Authentication
- SHA256 para hashing de passwords

FRONTEND:
- Blazor WebAssembly
- MudBlazor (Material Design)
- Blazored.LocalStorage
- HttpClient para llamadas API
- Custom AuthenticationStateProvider

HERRAMIENTAS:
- Visual Studio 2022
- Git (Branch: 8-usuario-por-autogesti√≥n)

================================================================================
VALIDACIONES IMPLEMENTADAS
================================================================================

BACKEND (Data Annotations):
‚úì Campos requeridos (Required)
‚úì Validaci√≥n de email (EmailAddress)
‚úì Validaci√≥n de tel√©fono (Phone)
‚úì Longitud m√°xima de strings (StringLength)
‚úì Longitud m√≠nima de password (MinimumLength: 6)
‚úì Comparaci√≥n de passwords (Compare)

BACKEND (L√≥gica de negocio):
‚úì Email de comercio √∫nico en toda la BD
‚úì Email de usuario √∫nico en toda la BD
‚úì Email de cliente √∫nico por comercio
‚úì Comercio debe existir al registrar cliente
‚úì Creaci√≥n autom√°tica de CuentaCorriente al crear Cliente

FRONTEND (MudBlazor):
‚úì Validaci√≥n en tiempo real
‚úì Mensajes de error personalizados
‚úì Validaci√≥n de formato de email
‚úì Validaci√≥n de campos requeridos
‚úì Comparaci√≥n de passwords en cliente

================================================================================
SEGURIDAD
================================================================================

IMPLEMENTADO:
‚úì Passwords hasheados con SHA256
‚úì JWT Token con expiraci√≥n de 24 horas
‚úì Claims en JWT: UserId, Email, Name, Role, ComercioId
‚úì CORS configurado para Blazor WASM
‚úì Endpoints de registro sin autenticaci√≥n (p√∫blicos)
‚úì Validaci√≥n de ModelState en controllers
‚úì Soft delete en todas las entidades

RECOMENDACIONES FUTURAS:
‚ö† Cambiar de SHA256 a BCrypt o Argon2 (m√°s seguro)
‚ö† Implementar rate limiting en endpoints de registro
‚ö† A√±adir verificaci√≥n de email
‚ö† A√±adir CAPTCHA para prevenir bots
‚ö† Implementar refresh tokens
‚ö† Logs de auditor√≠a de registros

================================================================================
TESTING
================================================================================

ESTADO: Compilaci√≥n exitosa
- Todos los proyectos compilan sin errores
- Warnings menores no cr√≠ticos

TESTS PENDIENTES:
‚ñ° Unit tests de servicios
‚ñ° Integration tests de endpoints
‚ñ° Tests de validaciones
‚ñ° Tests de UI con bUnit

TESTING MANUAL RECOMENDADO:
1. Registrar comercio nuevo
   - Verificar creaci√≥n en BD
   - Verificar usuario admin creado
   - Verificar login autom√°tico con token
   - Verificar redirecci√≥n a /admin/clientes

2. Registrar cliente
   - Verificar que aparezcan comercios en dropdown
   - Verificar creaci√≥n de cliente
   - Verificar creaci√≥n autom√°tica de cuenta corriente
   - Verificar redirecci√≥n a login

3. Validaciones
   - Email duplicado de comercio
   - Email duplicado de usuario
   - Email duplicado de cliente en mismo comercio
   - Passwords no coinciden
   - Campos requeridos vac√≠os

================================================================================
PR√ìXIMOS PASOS SUGERIDOS
================================================================================

1. FUNCIONALIDAD:
   ‚ñ° Implementar "Olvid√© mi contrase√±a"
   ‚ñ° A√±adir verificaci√≥n de email
   ‚ñ° Permitir a clientes crear password para autogesti√≥n
   ‚ñ° Dashboard para clientes registrados
   ‚ñ° Notificaciones de registro por email

2. SEGURIDAD:
   ‚ñ° Migrar de SHA256 a BCrypt
   ‚ñ° Implementar rate limiting
   ‚ñ° A√±adir CAPTCHA
   ‚ñ° Implementar refresh tokens
   ‚ñ° Two-factor authentication (2FA)

3. UX/UI:
   ‚ñ° Wizard multi-paso para registro de comercio
   ‚ñ° Validaci√≥n as√≠ncrona de emails (verificar duplicados en tiempo real)
   ‚ñ° Preview de plan/precio antes de registrar comercio
   ‚ñ° Onboarding despu√©s del primer registro
   ‚ñ° Tour guiado para nuevos usuarios

4. T√âCNICO:
   ‚ñ° A√±adir tests unitarios
   ‚ñ° Implementar logging estructurado (Serilog)
   ‚ñ° Configurar Health Checks
   ‚ñ° Implementar versionado de API
   ‚ñ° Documentaci√≥n Swagger mejorada

================================================================================
NOTAS IMPORTANTES
================================================================================

‚Ä¢ El sistema permite registros sin verificaci√≥n de email (futuro)
‚Ä¢ Los clientes NO tienen login autom√°tico (solo comercios)
‚Ä¢ Las cuentas corrientes se crean autom√°ticamente con l√≠mite 0
‚Ä¢ Los passwords se hashean con SHA256 (recomendado cambiar a BCrypt)
‚Ä¢ Todos los campos tienen soft delete (Activo = false)
‚Ä¢ El token JWT incluye ComercioId para multi-tenancy
‚Ä¢ El sistema est√° preparado para multi-comercio desde el dise√±o

================================================================================
IMPLEMENTACI√ìN: Sistema de Aprobaci√≥n de Clientes con Autogesti√≥n
================================================================================
Fecha: 2025-11-20
Branch: 8-usuario-por-autogesti√≥n

DESCRIPCI√ìN:
------------
Se implement√≥ un sistema completo de aprobaci√≥n de clientes que diferencia entre
clientes creados por administradores (aprobados autom√°ticamente) y clientes que
se auto-registran (requieren aprobaci√≥n manual del comercio).

DECISI√ìN ARQUITECT√ìNICA CLAVE:
-------------------------------
‚úì TABLA USUARIO UNIFICADA (Implementado)
  - Usuarios con rol "Cliente" autentican en tabla Usuario
  - Cliente.UsuarioId es FK nullable a Usuario
  - Beneficios:
    ‚Ä¢ Sistema de autenticaci√≥n unificado
    ‚Ä¢ Mejor arquitectura a largo plazo
    ‚Ä¢ Facilita implementaci√≥n de roles
    ‚Ä¢ No duplica l√≥gica de passwords

‚úó PASSWORDHASH EN CLIENTE (Rechazado)
  - Habr√≠a duplicado l√≥gica de autenticaci√≥n
  - Dif√≠cil de mantener

================================================================================
ARCHIVOS CREADOS/MODIFICADOS
================================================================================

BACKEND - MODEL (ENTIDADES)
---------------------------

NUEVOS ARCHIVOS:
1. SaasACC.Model/Entities/EstadoCliente.cs
   - Nueva entidad para estados de cliente
   - Estados: Pendiente (1), Activo (2), Inactivo (3)
   - Sistema extensible para agregar m√°s estados en el futuro
   - Campos:
     ‚Ä¢ Id (int)
     ‚Ä¢ Nombre (string)
     ‚Ä¢ Descripcion (string?)
     ‚Ä¢ Clientes (ICollection<Cliente>)

ARCHIVOS MODIFICADOS:
1. SaasACC.Model/Entities/Cliente.cs
   - A√±adido EstadoId (int) - FK a EstadoCliente
   - A√±adido UsuarioId (int?) - FK nullable a Usuario
   - A√±adido OrigenRegistro (int):
     ‚Ä¢ 1: Administraci√≥n (creado por admin)
     ‚Ä¢ 2: Autogesti√≥n (auto-registrado)
   - A√±adido FechaAprobacion (DateTime?)
   - A√±adido AprobadoPorUsuarioId (int?) - FK a Usuario
   - Navegaci√≥n: Estado, Usuario, AprobadoPor

2. SaasACC.Model/Entities/Usuario.cs
   - A√±adido Apellido (string?)
   - Modificado Rol para soportar "Cliente"
   - A√±adido ClientesAprobados (ICollection<Cliente>)

BACKEND - INFRASTRUCTURE (BASE DE DATOS)
-----------------------------------------

ARCHIVOS MODIFICADOS:
1. SaasACC.Infrastructure/ApplicationDbContext.cs
   - A√±adido DbSet<EstadoCliente>
   - Configuraci√≥n de EstadoCliente:
     ‚Ä¢ HasData con 3 estados iniciales
   - Configuraci√≥n de Cliente:
     ‚Ä¢ Relaci√≥n con EstadoCliente (requerida)
     ‚Ä¢ Relaci√≥n con Usuario (nullable)
     ‚Ä¢ Relaci√≥n con AprobadoPor (nullable)
     ‚Ä¢ OnDelete: Restrict para evitar cascadas
   - Configuraci√≥n de Usuario:
     ‚Ä¢ Relaci√≥n ClientesAprobados (sin FK inversa)

2. SaasACC.Infrastructure/Migrations/20251121020405_AgregarSistemaAprobacionClientes.cs
   - Creaci√≥n de tabla EstadoCliente
   - Seed de 3 estados iniciales
   - A√±adidas columnas a Cliente:
     ‚Ä¢ EstadoId (int, requerido, default 2)
     ‚Ä¢ UsuarioId (int?, nullable)
     ‚Ä¢ OrigenRegistro (int, default 1)
     ‚Ä¢ FechaAprobacion (DateTime?)
     ‚Ä¢ AprobadoPorUsuarioId (int?)
   - A√±adida columna a Usuario:
     ‚Ä¢ Apellido (string?, max 100)
   - MIGRACI√ìN DE DATOS EXISTENTES:
     ‚Ä¢ UPDATE Clientes SET EstadoId = 2, OrigenRegistro = 2
     ‚Ä¢ Marca todos los clientes existentes como Activos y de Autogesti√≥n
   - √çndices en FK para mejor performance
   - Constraints de FK con OnDelete Restrict

BACKEND - REPOSITORIES
----------------------

ARCHIVOS MODIFICADOS:
1. SaasACC.Application/Interfaces/IClienteRepository.cs
   - Modificado GetAllAsync(comercioId, estadoId?) - A√±adido filtro opcional
   - A√±adido CrearCuentaCorrienteAsync(clienteId)

2. SaasACC.Infrastructure/Repositories/ClienteRepository.cs
   - Modificado GetAllAsync:
     ‚Ä¢ Include de Estado, Usuario
     ‚Ä¢ Filtro condicional por EstadoId
     ‚Ä¢ Query optimizada

   - Implementado CrearCuentaCorrienteAsync:
     ‚Ä¢ Verifica si ya existe cuenta corriente
     ‚Ä¢ Crea nueva si no existe
     ‚Ä¢ Inicializa con l√≠mite 0
     ‚Ä¢ Retorna cuenta creada o existente

   - Modificado CreateAsync:
     ‚Ä¢ YA NO crea cuenta corriente autom√°ticamente
     ‚Ä¢ La cuenta se crea solo en aprobaci√≥n

BACKEND - SERVICES
------------------

ARCHIVOS MODIFICADOS:
1. SaasACC.Application/Services/ClienteService.cs (IClienteService)
   - A√±adidos m√©todos a interfaz:
     ‚Ä¢ GetClientesPendientesAsync(comercioId)
     ‚Ä¢ AprobarClienteAsync(clienteId, aprobadoPorUsuarioId)
     ‚Ä¢ RechazarClienteAsync(clienteId, rechazadoPorUsuarioId)

   - Modificado CreateClienteAsync:
     ‚Ä¢ EstadoId = 2 (Activo) - auto-aprobado
     ‚Ä¢ OrigenRegistro = 1 (Administraci√≥n)
     ‚Ä¢ FechaAprobacion = DateTime.UtcNow
     ‚Ä¢ Crea cuenta corriente inmediatamente
     ‚Ä¢ Recarga cliente con cuenta antes de retornar

   - Implementado GetClientesPendientesAsync:
     ‚Ä¢ Llama a GetAllAsync con estadoId = 1
     ‚Ä¢ Retorna lista de ClienteDto

   - Implementado AprobarClienteAsync:
     ‚Ä¢ Valida que cliente existe
     ‚Ä¢ Valida que no est√© ya aprobado
     ‚Ä¢ Cambia EstadoId a 2 (Activo)
     ‚Ä¢ Establece FechaAprobacion
     ‚Ä¢ Registra AprobadoPorUsuarioId
     ‚Ä¢ Crea cuenta corriente
     ‚Ä¢ Recarga cliente con cuenta
     ‚Ä¢ Retorna ClienteDto

   - Implementado RechazarClienteAsync:
     ‚Ä¢ Valida que cliente existe
     ‚Ä¢ Cambia EstadoId a 3 (Inactivo)
     ‚Ä¢ Registra quien rechaz√≥ en AprobadoPorUsuarioId
     ‚Ä¢ NO crea cuenta corriente
     ‚Ä¢ Retorna ClienteDto

2. SaasACC.Application/Services/AuthService.cs
   - Modificado LoginAsync:
     ‚Ä¢ Si usuario.Rol == "Cliente":
       - Busca cliente asociado por email
       - Valida que cliente.EstadoId == 2 (Activo)
       - Si EstadoId == 1: "Pendiente de aprobaci√≥n"
       - Si EstadoId == 3: "Cuenta inactivada"
       - Incluye ClienteId en el token
     ‚Ä¢ Token JWT incluye claim "ClienteId" si aplica

   - Modificado RegisterClienteAsync:
     ‚Ä¢ Crea Usuario con rol "Cliente" PRIMERO
     ‚Ä¢ Hashea password
     ‚Ä¢ Crea Cliente vinculado a Usuario:
       - UsuarioId = usuario.Id
       - EstadoId = 1 (Pendiente)
       - OrigenRegistro = 2 (Autogesti√≥n)
     ‚Ä¢ NO crea cuenta corriente (se crea en aprobaci√≥n)
     ‚Ä¢ NO genera token (cliente debe esperar aprobaci√≥n)

BACKEND - DTOs
--------------

ARCHIVOS MODIFICADOS:
1. SaasACC.Model/DTOs/ClienteDto.cs
   - A√±adido EstadoId (int)
   - A√±adido EstadoNombre (string)
   - A√±adido OrigenRegistro (int)
   - A√±adido OrigenRegistroNombre (string) - Computed:
     ‚Ä¢ OrigenRegistro == 1 ‚Üí "Administraci√≥n"
     ‚Ä¢ OrigenRegistro == 2 ‚Üí "Autogesti√≥n"
   - A√±adido TieneUsuario (bool)
   - A√±adido FechaAprobacion (DateTime?)

BACKEND - API (CONTROLLERS)
---------------------------

ARCHIVOS MODIFICADOS:
1. SaasACCAPI.api/Controllers/ClientesController.cs
   - Modificado GetClientes:
     ‚Ä¢ A√±adido par√°metro [FromQuery] int? estadoId
     ‚Ä¢ Pasa estadoId al servicio para filtrado

   - A√±adido endpoint GetClientesPendientes:
     ‚Ä¢ [HttpGet("pendientes")]
     ‚Ä¢ Retorna solo clientes con EstadoId = 1
     ‚Ä¢ Requiere autenticaci√≥n

   - A√±adido endpoint AprobarCliente:
     ‚Ä¢ [HttpPost("{id}/aprobar")]
     ‚Ä¢ Obtiene usuarioId del token
     ‚Ä¢ Llama a AprobarClienteAsync
     ‚Ä¢ Maneja InvalidOperationException (ya aprobado)
     ‚Ä¢ Retorna ClienteDto actualizado

   - A√±adido endpoint RechazarCliente:
     ‚Ä¢ [HttpPost("{id}/rechazar")]
     ‚Ä¢ Obtiene usuarioId del token
     ‚Ä¢ Llama a RechazarClienteAsync
     ‚Ä¢ Retorna ClienteDto actualizado

   - A√±adido m√©todo privado GetUsuarioIdFromToken:
     ‚Ä¢ Extrae NameIdentifier del token
     ‚Ä¢ Retorna int usuarioId
     ‚Ä¢ Throw UnauthorizedAccessException si falla

FRONTEND - BLAZOR WASM (PAGES)
------------------------------

NUEVOS ARCHIVOS:
1. SaasACC.BlazorWasm/Pages/Admin/ClientesPendientes.razor
   - P√°gina dedicada a clientes pendientes de aprobaci√≥n
   - Ruta: /admin/clientes-pendientes
   - Autorizaci√≥n: [Authorize(Roles = "Admin,SuperAdmin")]
   - Componentes:
     ‚Ä¢ MudCard con t√≠tulo
     ‚Ä¢ MudProgressCircular durante carga
     ‚Ä¢ MudAlert si no hay pendientes
     ‚Ä¢ MudTable con columnas:
       - Nombre completo
       - Email
       - Tel√©fono
       - DNI
       - Origen (chip con color)
       - Fecha de registro
       - Acciones (Aprobar/Rechazar)

   - M√©todos:
     ‚Ä¢ LoadClientesPendientes: GET api/clientes/pendientes
     ‚Ä¢ AprobarCliente: POST api/clientes/{id}/aprobar
     ‚Ä¢ RechazarCliente: POST api/clientes/{id}/rechazar

   - UX:
     ‚Ä¢ Botones verde (Aprobar) y rojo (Rechazar)
     ‚Ä¢ Iconos CheckCircle y Cancel
     ‚Ä¢ Snackbar con mensajes de √©xito/error
     ‚Ä¢ Recarga autom√°tica despu√©s de aprobar/rechazar
     ‚Ä¢ Bot√≥n "Volver a Clientes"

ARCHIVOS MODIFICADOS:
1. SaasACC.BlazorWasm/Pages/Admin/Clientes.razor
   - A√±adido filtro de estado:
     ‚Ä¢ MudSelect con opciones: Todos, Pendientes, Activos, Inactivos
     ‚Ä¢ Variable selectedEstadoId
     ‚Ä¢ Se pasa como query parameter a API

   - A√±adidas columnas en tabla:
     ‚Ä¢ Estado (MudChip con colores):
       - Pendiente: Warning (amarillo)
       - Activo: Success (verde)
       - Inactivo: Default (gris)
     ‚Ä¢ Origen (MudChip):
       - Administraci√≥n: Primary
       - Autogesti√≥n: Info

   - Modificadas acciones:
     ‚Ä¢ Si EstadoId == 1 (Pendiente):
       - Mostrar botones Aprobar/Rechazar
       - Iconos CheckCircle/Cancel
       - Colores Success/Error
     ‚Ä¢ Si EstadoId != 1:
       - Mostrar botones Edit/Delete normales

   - A√±adidos m√©todos:
     ‚Ä¢ AprobarCliente(cliente): POST api/clientes/{id}/aprobar
     ‚Ä¢ RechazarCliente(cliente): POST api/clientes/{id}/rechazar

   - A√±adido bot√≥n de acceso r√°pido:
     ‚Ä¢ "Ver Pendientes" (solo si hay pendientes)
     ‚Ä¢ Navega a /admin/clientes-pendientes
     ‚Ä¢ Badge con cantidad de pendientes

2. SaasACC.BlazorWasm/App.razor
   - A√±adido <MudPopoverProvider /> despu√©s de MudSnackbarProvider
   - Fix para error "Missing <MudPopoverProvider />"

================================================================================
ENDPOINTS API CREADOS/MODIFICADOS
================================================================================

MODIFICADOS:
1. GET /api/clientes?estadoId={estadoId}
   Query Parameters:
   - estadoId (int?, opcional): 1=Pendiente, 2=Activo, 3=Inactivo

   Response: Array<ClienteDto>
   - Incluye nuevos campos: EstadoId, EstadoNombre, OrigenRegistro, etc.

NUEVOS:
2. GET /api/clientes/pendientes
   Descripci√≥n: Obtiene solo clientes pendientes de aprobaci√≥n
   Autorizaci√≥n: Requerida (token JWT)

   Response: Array<ClienteDto>
   [
     {
       "id": 5,
       "nombre": "Juan",
       "apellido": "P√©rez",
       "nombreCompleto": "Juan P√©rez",
       "email": "juan@example.com",
       "estadoId": 1,
       "estadoNombre": "Pendiente",
       "origenRegistro": 2,
       "origenRegistroNombre": "Autogesti√≥n",
       "tieneUsuario": true,
       "fechaAprobacion": null,
       "cuentaCorriente": null
     }
   ]

3. POST /api/clientes/{id}/aprobar
   Descripci√≥n: Aprueba un cliente pendiente
   Autorizaci√≥n: Requerida (obtiene usuarioId del token)

   Request: Sin body

   Response: ClienteDto
   {
     "id": 5,
     "estadoId": 2,
     "estadoNombre": "Activo",
     "fechaAprobacion": "2025-11-20T10:30:00Z",
     "cuentaCorriente": {
       "id": 8,
       "clienteId": 5,
       "saldo": 0,
       "fechaCreacion": "2025-11-20T10:30:00Z"
     }
   }

   Errores:
   - 400: Cliente ya est√° aprobado
   - 400: Cliente no encontrado
   - 500: Error interno

4. POST /api/clientes/{id}/rechazar
   Descripci√≥n: Rechaza un cliente pendiente
   Autorizaci√≥n: Requerida (obtiene usuarioId del token)

   Request: Sin body

   Response: ClienteDto
   {
     "id": 5,
     "estadoId": 3,
     "estadoNombre": "Inactivo"
   }

================================================================================
CAMBIOS EN BASE DE DATOS
================================================================================

NUEVA TABLA:
1. EstadoCliente
   - Id (int, PK)
   - Nombre (nvarchar(50))
   - Descripcion (nvarchar(200), nullable)

   DATOS INICIALES:
   | Id | Nombre    | Descripcion               |
   |----|-----------|---------------------------|
   | 1  | Pendiente | Pendiente de aprobaci√≥n   |
   | 2  | Activo    | Cliente activo            |
   | 3  | Inactivo  | Cliente inactivo          |

COLUMNAS A√ëADIDAS A CLIENTES:
- EstadoId (int, NOT NULL, DEFAULT 2, FK ‚Üí EstadoCliente)
- UsuarioId (int, NULL, FK ‚Üí Usuarios)
- OrigenRegistro (int, NOT NULL, DEFAULT 1)
- FechaAprobacion (datetime2, NULL)
- AprobadoPorUsuarioId (int, NULL, FK ‚Üí Usuarios)

COLUMNAS A√ëADIDAS A USUARIOS:
- Apellido (nvarchar(100), NULL)

√çNDICES CREADOS:
- IX_Clientes_EstadoId
- IX_Clientes_UsuarioId
- IX_Clientes_AprobadoPorUsuarioId

FOREIGN KEYS:
- FK_Clientes_EstadoCliente_EstadoId (ON DELETE RESTRICT)
- FK_Clientes_Usuarios_UsuarioId (ON DELETE RESTRICT)
- FK_Clientes_Usuarios_AprobadoPorUsuarioId (ON DELETE RESTRICT)

MIGRACI√ìN DE DATOS:
- Todos los clientes existentes:
  ‚Ä¢ EstadoId = 2 (Activo)
  ‚Ä¢ OrigenRegistro = 2 (Autogesti√≥n)

================================================================================
FLUJO DE USUARIO ACTUALIZADO
================================================================================

FLUJO 1: ADMINISTRADOR CREA CLIENTE
------------------------------------
1. Admin ingresa a /admin/clientes
2. Click en "Nuevo Cliente"
3. Completa formulario
4. Al guardar:
   Backend:
   - Crea Cliente con EstadoId = 2 (Activo)
   - OrigenRegistro = 1 (Administraci√≥n)
   - FechaAprobacion = ahora
   - Crea CuentaCorriente inmediatamente
   Frontend:
   - Muestra mensaje de √©xito
   - Cliente aparece en lista como "Activo"
   - Origen: "Administraci√≥n"

FLUJO 2: CLIENTE SE AUTO-REGISTRA
----------------------------------
1. Usuario visita /register
2. Click en "Registrar Cliente"
3. Selecciona comercio del dropdown
4. Completa formulario (nombre, email, password, etc.)
5. Al enviar:
   Backend:
   - Crea Usuario con rol "Cliente"
   - Crea Cliente con:
     ‚Ä¢ UsuarioId = usuario.Id
     ‚Ä¢ EstadoId = 1 (Pendiente)
     ‚Ä¢ OrigenRegistro = 2 (Autogesti√≥n)
   - NO crea CuentaCorriente a√∫n
   Frontend:
   - Mensaje: "Registro exitoso. Espera aprobaci√≥n del comercio"
   - Redirige a /login

FLUJO 3: CLIENTE INTENTA LOGIN (PENDIENTE)
-------------------------------------------
1. Cliente ingresa email/password
2. Backend:
   - Valida credenciales
   - Busca Cliente asociado
   - Verifica EstadoId
   - Como EstadoId == 1 (Pendiente):
     ‚Ä¢ Retorna error: "Tu cuenta est√° pendiente de aprobaci√≥n"
3. Frontend:
   - Muestra mensaje de error
   - No permite acceso

FLUJO 4: ADMIN APRUEBA CLIENTE
-------------------------------
1. Admin ve notificaci√≥n de clientes pendientes
2. Navega a /admin/clientes-pendientes
   O
   Filtra por "Pendientes" en /admin/clientes
3. Ve lista de clientes con estado "Pendiente"
4. Click en bot√≥n "Aprobar"
5. Backend:
   - Cambia EstadoId a 2 (Activo)
   - Registra FechaAprobacion
   - Registra AprobadoPorUsuarioId
   - Crea CuentaCorriente
6. Frontend:
   - Mensaje: "{Nombre} aprobado correctamente"
   - Cliente desaparece de lista de pendientes
   - Aparece en lista de activos

FLUJO 5: CLIENTE LOGIN DESPU√âS DE APROBACI√ìN
---------------------------------------------
1. Cliente ingresa email/password
2. Backend:
   - Valida credenciales
   - Busca Cliente asociado
   - Verifica EstadoId
   - Como EstadoId == 2 (Activo):
     ‚Ä¢ Genera token JWT con ClienteId
     ‚Ä¢ Login exitoso
3. Frontend:
   - Guarda token
   - Redirige a dashboard de cliente (futuro)

FLUJO 6: ADMIN RECHAZA CLIENTE
-------------------------------
1. Admin en p√°gina de pendientes
2. Click en bot√≥n "Rechazar"
3. Backend:
   - Cambia EstadoId a 3 (Inactivo)
   - Registra quien rechaz√≥
   - NO crea cuenta corriente
4. Frontend:
   - Mensaje: "{Nombre} rechazado"
   - Cliente desaparece de pendientes
   - Si intenta login: "Cuenta inactivada. Contacta al comercio"

================================================================================
VALIDACIONES IMPLEMENTADAS
================================================================================

BACKEND:
‚úì Cliente debe existir para aprobar/rechazar
‚úì No se puede aprobar un cliente ya aprobado
‚úì Usuario debe estar autenticado para aprobar/rechazar
‚úì Al auto-registrarse, comercio debe existir
‚úì Email √∫nico por comercio
‚úì CuentaCorriente se crea solo una vez (valida existencia)
‚úì Login solo permitido para clientes con EstadoId = 2
‚úì Mensajes de error espec√≠ficos por estado:
  - EstadoId 1: "Pendiente de aprobaci√≥n"
  - EstadoId 3: "Cuenta inactivada"

FRONTEND:
‚úì Botones de aprobar/rechazar solo para EstadoId = 1
‚úì Filtros por estado funcionan correctamente
‚úì Recarga autom√°tica despu√©s de aprobar/rechazar
‚úì Mensajes claros de √©xito/error

================================================================================
DECISIONES DE DISE√ëO
================================================================================

1. **Tabla de Estados Extensible**
   ‚úì Por qu√©: Permite agregar nuevos estados en el futuro sin cambiar c√≥digo
   Ejemplos futuros: "Suspendido", "En Revisi√≥n", "Bloqueado"

2. **UsuarioId Nullable en Cliente**
   ‚úì Por qu√©: Permite clientes creados por admin sin usuario inicialmente
   ‚úì Clientes de autogesti√≥n siempre tienen UsuarioId
   ‚úì Clientes de admin pueden tener UsuarioId si se les crea credenciales

3. **Cuenta Corriente en Aprobaci√≥n**
   ‚úì Por qu√©: No tiene sentido tener cuenta si no est√° aprobado
   ‚úì Evita cuentas "fantasma" de clientes rechazados
   ‚úì Admin-created clients: aprobaci√≥n autom√°tica, cuenta inmediata

4. **OrigenRegistro como Int**
   ‚úì Por qu√©: M√°s eficiente que string, extensible
   ‚úì Futuro: agregar origen "Importaci√≥n", "API", etc.

5. **AprobadoPorUsuarioId para Rechazos**
   ‚úì Por qu√©: Mantener auditor√≠a de qui√©n rechaz√≥
   ‚úì √ötil para reportes y seguimiento

6. **ON DELETE RESTRICT en FKs**
   ‚úì Por qu√©: Previene eliminaci√≥n accidental en cascada
   ‚úì Seguridad: no se puede borrar estado si tiene clientes
   ‚úì No se puede borrar usuario que aprob√≥ clientes

7. **P√°gina Separada para Pendientes**
   ‚úì Por qu√©: Mejora UX, admin puede enfocarse en aprobaciones
   ‚úì Alternativa: solo filtro en lista principal tambi√©n disponible

================================================================================
TECNOLOG√çAS Y PATRONES UTILIZADOS
================================================================================

BACKEND:
- Entity Framework Core - Migrations
- ASP.NET Core - Controllers, Authorization
- Repository Pattern
- Service Layer Pattern
- DTO Pattern
- Dependency Injection
- JWT Claims para autorizaci√≥n
- Soft Delete Pattern
- State Machine Pattern (EstadoCliente)

FRONTEND:
- Blazor WebAssembly
- MudBlazor:
  ‚Ä¢ MudTable
  ‚Ä¢ MudChip (estados y or√≠genes)
  ‚Ä¢ MudSelect (filtros)
  ‚Ä¢ MudButton
  ‚Ä¢ MudSnackbar (notificaciones)
  ‚Ä¢ MudProgressCircular
  ‚Ä¢ MudAlert
- Component-based architecture
- Async/await pattern
- HttpClient para API calls

BASE DE DATOS:
- SQL Server LocalDB
- Foreign Keys con constraints
- Indexes en FK para performance
- Data seeding
- Data migration scripts

================================================================================
TESTING
================================================================================

COMPILACI√ìN:
‚úì Build exitoso sin errores
‚ö† Warnings menores (nullable references, MudBlazor deprecations)

MIGRACI√ìN:
‚úì Migration aplicada correctamente
‚úì Datos existentes migrados (EstadoId=2, OrigenRegistro=2)
‚úì Tablas creadas
‚úì Foreign keys establecidas
‚úì √çndices creados

PRUEBAS MANUALES RECOMENDADAS:
1. ‚úì Crear cliente desde admin
   - Verificar EstadoId = 2
   - Verificar cuenta corriente creada
   - Verificar origen "Administraci√≥n"

2. ‚úì Auto-registro de cliente
   - Verificar EstadoId = 1
   - Verificar NO tiene cuenta corriente
   - Verificar origen "Autogesti√≥n"
   - Verificar UsuarioId est√° establecido

3. ‚úì Login con cliente pendiente
   - Verificar mensaje de error apropiado
   - Verificar que no se genera token

4. ‚úì Aprobar cliente
   - Verificar cambio de estado a Activo
   - Verificar creaci√≥n de cuenta corriente
   - Verificar FechaAprobacion
   - Verificar AprobadoPorUsuarioId

5. ‚úì Login con cliente aprobado
   - Verificar token generado
   - Verificar claim ClienteId en token

6. ‚úì Rechazar cliente
   - Verificar cambio de estado a Inactivo
   - Verificar NO se crea cuenta corriente

7. ‚úì Filtros en lista de clientes
   - Todos, Pendientes, Activos, Inactivos

8. ‚úì P√°gina de pendientes
   - Listar solo pendientes
   - Aprobar desde p√°gina
   - Rechazar desde p√°gina

================================================================================
PR√ìXIMOS PASOS SUGERIDOS
================================================================================

FUNCIONALIDAD:
‚ñ° Notificaciones al comercio cuando hay nuevo pendiente
‚ñ° Email al cliente cuando es aprobado/rechazado
‚ñ° Permitir al cliente cambiar su password
‚ñ° Dashboard para clientes aprobados
‚ñ° Historial de aprobaciones/rechazos
‚ñ° Raz√≥n de rechazo (campo adicional)
‚ñ° Re-activaci√≥n de clientes rechazados
‚ñ° Bulk approval (aprobar m√∫ltiples a la vez)

SEGURIDAD:
‚ñ° Rate limiting en auto-registro
‚ñ° CAPTCHA en formulario de auto-registro
‚ñ° Verificaci√≥n de email antes de aprobar
‚ñ° Logs de auditor√≠a de aprobaciones

UX/UI:
‚ñ° Notificaci√≥n badge en men√∫ con cantidad de pendientes
‚ñ° Confirmaci√≥n antes de rechazar
‚ñ° Raz√≥n de rechazo (textarea)
‚ñ° Filtro combinado (estado + origen)
‚ñ° Exportar lista de pendientes
‚ñ° Vista previa de cliente antes de aprobar

T√âCNICO:
‚ñ° Unit tests de AprobacionService
‚ñ° Integration tests de endpoints
‚ñ° Tests de migraci√≥n de datos
‚ñ° Performance test con muchos clientes
‚ñ° Logging estructurado de aprobaciones
‚ñ° M√©tricas: tiempo promedio de aprobaci√≥n

================================================================================
NOTAS IMPORTANTES
================================================================================

‚Ä¢ Los clientes creados por admin se aprueban autom√°ticamente
‚Ä¢ Los clientes auto-registrados quedan pendientes
‚Ä¢ La cuenta corriente se crea SOLO al aprobar
‚Ä¢ Clientes pendientes o inactivos NO pueden hacer login
‚Ä¢ El sistema registra qui√©n aprob√≥/rechaz√≥ cada cliente
‚Ä¢ Estados son extensibles (f√°cil agregar nuevos)
‚Ä¢ Origen es extensible (futuro: importaci√≥n, API, etc.)
‚Ä¢ Todos los clientes existentes fueron marcados como Autogesti√≥n/Activo
‚Ä¢ Usuario.Apellido fue a√±adido para soportar rol Cliente
‚Ä¢ Usuario.Rol ahora incluye "Cliente" adem√°s de Admin/Usuario/SuperAdmin
‚Ä¢ Foreign Keys tienen ON DELETE RESTRICT para seguridad
‚Ä¢ AprobadoPorUsuarioId se usa tanto para aprobaci√≥n como rechazo (auditor√≠a)

ARQUITECTURA:
‚Ä¢ Cliente.UsuarioId nullable permite clientes sin credenciales (creados por admin)
‚Ä¢ Clientes de autogesti√≥n SIEMPRE tienen UsuarioId
‚Ä¢ Sistema de autenticaci√≥n unificado en tabla Usuario
‚Ä¢ No hay duplicaci√≥n de l√≥gica de passwords
‚Ä¢ F√°cil extender a otros roles en el futuro

FLUJO CR√çTICO:
1. Auto-registro ‚Üí Usuario creado + Cliente creado (EstadoId=1, sin cuenta)
2. Login pendiente ‚Üí ERROR: "Pendiente de aprobaci√≥n"
3. Admin aprueba ‚Üí EstadoId=2, cuenta corriente creada
4. Login aprobado ‚Üí SUCCESS: Token generado con ClienteId

================================================================================
FIN DEL RESUMEN
================================================================================
